<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>IG Carousel Maker</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Golos+Text:wght@400;600;700&family=Inter:wght@400;600;700&family=Manrope:wght@400;600;800&family=Montserrat:wght@400;600;700&family=Rubik:wght@400;600;700&display=swap");

      :root {
        --bg-1: #0b0f19;
        --bg-2: #151b2f;
        --accent-1: #00d4ff;
        --accent-2: #f4b86a;
        --text: #f5f7ff;
        --muted: #9aa3b2;
        --card: rgba(255, 255, 255, 0.06);
        --stroke: rgba(255, 255, 255, 0.12);
        --light: #f7f6f2;
        --dark: #0f1220;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Manrope", system-ui, -apple-system, sans-serif;
        color: var(--text);
        background: radial-gradient(1200px 800px at 15% 10%, #1d2450 0%, transparent 55%),
          radial-gradient(900px 700px at 80% 20%, #2a0f2f 0%, transparent 60%),
          linear-gradient(180deg, var(--bg-1), var(--bg-2));
        min-height: 100vh;
      }

      .page {
        max-width: 1100px;
        margin: 0 auto;
        padding: 40px 24px 80px;
        display: grid;
        gap: 24px;
      }

      header {
        display: grid;
        gap: 10px;
      }

      header h1 {
        font-family: "Space Grotesk", system-ui, sans-serif;
        font-size: clamp(28px, 4vw, 44px);
        margin: 0;
        letter-spacing: 0.3px;
      }

      header p {
        margin: 0;
        color: var(--muted);
      }

      .panel {
        display: grid;
        gap: 16px;
        padding: 18px;
        border-radius: 18px;
        background: var(--card);
        border: 1px solid var(--stroke);
        backdrop-filter: blur(14px);
      }

      .panel-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .step-panel {
        display: grid;
        gap: 12px;
        padding: 24px;
        border-radius: 18px;
        background: var(--card);
        border: 1px solid var(--stroke);
        backdrop-filter: blur(14px);
      }

      .step-header {
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .step-number {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--accent-1), #8bf0ff);
        color: var(--dark);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: 20px;
        flex-shrink: 0;
      }

      .step-title {
        font-size: 18px;
        font-weight: 600;
        color: var(--text);
      }

      .step-description {
        margin: 0;
        color: var(--muted);
        font-size: 14px;
        line-height: 1.5;
        padding-left: 56px;
      }

      .controls {
        display: grid;
        gap: 16px;
      }

      textarea {
        width: 100%;
        min-height: 180px;
        resize: vertical;
        border-radius: 14px;
        border: 1px solid var(--stroke);
        background: rgba(10, 13, 24, 0.7);
        color: var(--text);
        padding: 14px 16px;
        font-size: 16px;
        line-height: 1.5;
        outline: none;
      }

      input[type="text"] {
        width: 100%;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: rgba(10, 13, 24, 0.7);
        color: var(--text);
        padding: 10px 12px;
        font-size: 14px;
        outline: none;
      }

      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }

      select,
      button {
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: rgba(14, 18, 32, 0.85);
        color: var(--text);
        padding: 10px 14px;
        font-size: 15px;
        cursor: pointer;
      }

      button.primary {
        background: linear-gradient(135deg, var(--accent-1), #8bf0ff);
        color: #0b0f19;
        font-weight: 700;
        border: none;
      }

      button.secondary {
        border: 1px solid rgba(0, 212, 255, 0.4);
        color: var(--accent-1);
      }

      button.ghost {
        border: 1px solid var(--stroke);
        color: var(--muted);
        background: rgba(14, 18, 32, 0.5);
      }

      button.zip {
        border: 1px dashed rgba(0, 212, 255, 0.35);
        color: #cfeaff;
        background: rgba(8, 12, 24, 0.65);
        font-weight: 600;
      }

      .meta {
        font-size: 13px;
        color: var(--muted);
      }

      .picker {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(72px, 1fr));
        gap: 8px;
      }

      .chip {
        display: grid;
        gap: 4px;
        padding: 8px;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: rgba(14, 18, 32, 0.85);
        color: var(--text);
        cursor: pointer;
        text-align: left;
      }

      .chip.active {
        border-color: rgba(0, 212, 255, 0.5);
        box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2);
      }

      .layout-thumb,
      .color-thumb {
        height: 32px;
        border-radius: 10px;
        border: 1px solid var(--stroke);
        background: #f6f3ee;
        position: relative;
        overflow: hidden;
      }

      .layout-thumb[data-layout="line"]::before {
        content: "";
        position: absolute;
        left: 6px;
        top: 6px;
        width: 22px;
        height: 3px;
        background: #141724;
        border-radius: 999px;
      }

      .layout-thumb[data-layout="frame"]::before {
        content: "";
        position: absolute;
        inset: 5px;
        border: 1px solid rgba(20, 23, 36, 0.5);
        border-radius: 8px;
      }

      .layout-thumb[data-layout="split"]::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 34%;
        background: rgba(47, 128, 237, 0.25);
      }

      .layout-thumb[data-layout="grid"] {
        background-image: repeating-linear-gradient(
            90deg,
            rgba(17, 19, 31, 0.1),
            rgba(17, 19, 31, 0.1) 1px,
            transparent 1px,
            transparent 9px
          ),
          repeating-linear-gradient(
            0deg,
            rgba(17, 19, 31, 0.1),
            rgba(17, 19, 31, 0.1) 1px,
            transparent 1px,
            transparent 9px
          );
      }

      .layout-thumb[data-layout="pill"]::before {
        content: "";
        position: absolute;
        left: 6px;
        top: 8px;
        width: 60%;
        height: 10px;
        background: rgba(47, 128, 237, 0.3);
        border-radius: 999px;
      }

      .layout-thumb[data-layout="corner"]::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        width: 0;
        height: 0;
        border-top: 26px solid rgba(47, 128, 237, 0.3);
        border-right: 36px solid transparent;
      }

      .layout-thumb[data-layout="dots"]::before {
        content: "";
        position: absolute;
        left: 8px;
        top: 8px;
        width: 6px;
        height: 6px;
        background: rgba(47, 128, 237, 0.4);
        border-radius: 50%;
        box-shadow: 12px 0 0 rgba(47, 128, 237, 0.4), 24px 0 0 rgba(47, 128, 237, 0.4),
                    0 12px 0 rgba(47, 128, 237, 0.4), 12px 12px 0 rgba(47, 128, 237, 0.4), 24px 12px 0 rgba(47, 128, 237, 0.4);
      }

      .layout-thumb[data-layout="stripes"]::before {
        content: "";
        position: absolute;
        left: 6px;
        top: 6px;
        right: 6px;
        bottom: 6px;
        background: repeating-linear-gradient(
          45deg,
          rgba(47, 128, 237, 0.15),
          rgba(47, 128, 237, 0.15) 3px,
          transparent 3px,
          transparent 8px
        );
      }

      .layout-thumb[data-layout="waves"]::before {
        content: "";
        position: absolute;
        left: 0;
        bottom: 0;
        width: 100%;
        height: 40%;
        background: linear-gradient(to top, rgba(47, 128, 237, 0.2), transparent);
        border-radius: 50% 50% 0 0 / 100% 100% 0 0;
      }

      .layout-thumb[data-layout="circle"]::before {
        content: "";
        position: absolute;
        right: 8px;
        bottom: 8px;
        width: 20px;
        height: 20px;
        border: 2px solid rgba(47, 128, 237, 0.4);
        border-radius: 50%;
      }

      .layout-thumb[data-layout="diamond"]::before {
        content: "";
        position: absolute;
        right: 10px;
        top: 10px;
        width: 14px;
        height: 14px;
        background: rgba(47, 128, 237, 0.3);
        transform: rotate(45deg);
      }

      .layout-thumb[data-layout="shadow"]::before {
        content: "";
        position: absolute;
        inset: 8px;
        background: rgba(47, 128, 237, 0.1);
        border-radius: 8px;
        box-shadow: 4px 4px 0 rgba(47, 128, 237, 0.2);
      }

      /* Chat theme preview */
      .layout-thumb[data-layout="chat"] {
        background: linear-gradient(180deg, #f5f5f7 0%, #e8e8ed 100%);
      }
      .layout-thumb[data-layout="chat"]::before {
        content: "";
        position: absolute;
        right: 6px;
        top: 6px;
        width: 26px;
        height: 14px;
        background: #007aff;
        border-radius: 10px;
        box-shadow: -20px 18px 0 -4px #e5e5ea, -20px 18px 0 -2px #fff;
      }

      /* Search theme preview */
      .layout-thumb[data-layout="search"] {
        background: #ffffff;
      }
      .layout-thumb[data-layout="search"]::before {
        content: "";
        position: absolute;
        left: 8px;
        top: 8px;
        right: 8px;
        height: 10px;
        background: #f1f3f4;
        border-radius: 10px;
        border: 1px solid #dfe1e5;
      }
      .layout-thumb[data-layout="search"]::after {
        content: "";
        position: absolute;
        left: 12px;
        top: 11px;
        width: 6px;
        height: 6px;
        border: 1.5px solid #9aa0a6;
        border-radius: 50%;
      }

      .color-thumb[data-palette="linen"] {
        background: linear-gradient(135deg, #fbf8f3, #e6e1d6);
      }

      .color-thumb[data-palette="ice"] {
        background: linear-gradient(135deg, #f3f7fb, #dfe9f8);
      }

      .color-thumb[data-palette="sand"] {
        background: linear-gradient(135deg, #fbf6ee, #ecd6be);
      }

      .color-thumb[data-palette="mint"] {
        background: linear-gradient(135deg, #f2fbf7, #c9f0df);
      }

      .color-thumb[data-palette="rose"] {
        background: linear-gradient(135deg, #fff5f7, #ffd0dc);
      }

      .color-thumb[data-palette="midnight"] {
        background: linear-gradient(135deg, #f4f6fb, #c8d3f6);
      }

      .color-thumb[data-palette="lavender"] {
        background: linear-gradient(135deg, #f8f5ff, #e9d5ff);
      }

      .color-thumb[data-palette="sage"] {
        background: linear-gradient(135deg, #f5f7f4, #c5d5b5);
      }

      .color-thumb[data-palette="coral"] {
        background: linear-gradient(135deg, #fff5f3, #fecaca);
      }

      .color-thumb[data-palette="white"] {
        background: linear-gradient(135deg, #ffffff, #f3f4f6);
      }

      .color-thumb[data-palette="black"] {
        background: linear-gradient(135deg, #262626, #0a0a0a);
      }

      .color-thumb[data-underlay="white"] {
        background: linear-gradient(135deg, #ffffff, #f1f1f1);
      }

      .color-thumb[data-underlay="cream"] {
        background: linear-gradient(135deg, #fff7e8, #f3e3c8);
      }

      .color-thumb[data-underlay="mist"] {
        background: linear-gradient(135deg, #eef3ff, #dfe7f7);
      }

      .color-thumb[data-underlay="mint"] {
        background: linear-gradient(135deg, #eefaf4, #d7f1e3);
      }

      .color-thumb[data-underlay="charcoal"] {
        background: linear-gradient(135deg, #1b1f2a, #0f1219);
      }

      .color-thumb[data-underlay="blush"] {
        background: linear-gradient(135deg, #fff0f5, #fbcfe8);
      }

      .color-thumb[data-underlay="sky"] {
        background: linear-gradient(135deg, #e0f2fe, #7dd3fc);
      }

      .color-thumb[data-underlay="sand"] {
        background: linear-gradient(135deg, #fefce8, #fde047);
      }

      .color-thumb[data-underlay="lavender"] {
        background: linear-gradient(135deg, #f3e8ff, #d8b4fe);
      }

      .color-thumb[data-underlay="peach"] {
        background: linear-gradient(135deg, #ffedd5, #fdba74);
      }

      .color-thumb[data-underlay="sage"] {
        background: linear-gradient(135deg, #dcfce7, #86efac);
      }

      .color-thumb[data-underlay="coral"] {
        background: linear-gradient(135deg, #fee2e2, #fca5a5);
      }

      .field {
        display: grid;
        gap: 6px;
        min-width: 240px;
      }

      .field label {
        font-size: 12px;
        color: var(--muted);
      }

      .preview-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
      }

      @media (max-width: 780px) {
        .page {
          padding: 20px 14px 60px;
        }

        .panel {
          padding: 14px;
        }

        .panel-head {
          justify-content: space-between;
        }

        button.zip {
          width: auto;
          white-space: nowrap;
        }

        .preview-grid {
          display: flex;
          flex-wrap: nowrap;
          gap: 12px;
          overflow-x: auto;
          padding: 8px 0 16px;
          scroll-snap-type: x mandatory;
          /* Prevent horizontal scrollbar from affecting layout */
          -webkit-overflow-scrolling: touch;
          width: 100%;
          box-sizing: border-box;
        }

        .preview-card {
          scroll-snap-align: start;
          flex: 0 0 calc(80vw - 30px); /* Show 20% of next card */
          max-width: calc(80vw - 30px);
          min-width: 180px;
        }
        
      }

      .preview-wrap {
        position: relative;
        min-height: 180px;
        overflow: hidden;
        width: 100%;
      }

      .preview-card {
        background: rgba(12, 16, 28, 0.85);
        border-radius: 16px;
        padding: 10px;
        border: 1px solid var(--stroke);
        cursor: pointer;
      }

      .preview-card canvas {
        width: 100%;
        height: auto;
        display: block;
        border-radius: 10px;
      }

      .empty {
        color: var(--muted);
        text-align: center;
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        pointer-events: none;
      }

      .modal {
        position: fixed;
        inset: 0;
        background: rgba(8, 10, 18, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 50;
        padding: 24px;
      }

      .modal.open {
        display: flex;
      }

      .modal-card {
        width: min(520px, 90vw);
        background: rgba(14, 18, 32, 0.95);
        border: 1px solid var(--stroke);
        border-radius: 16px;
        padding: 18px;
        display: grid;
        gap: 12px;
      }

      .modal-card h3 {
        margin: 0;
        font-size: 18px;
      }

      .option-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 10px;
      }

      .option-card {
        display: grid;
        gap: 8px;
        padding: 10px;
        border-radius: 14px;
        border: 1px solid rgba(0, 212, 255, 0.35);
        background: rgba(10, 14, 26, 0.7);
        color: #cfeaff;
        font-size: 13px;
        font-weight: 600;
        text-align: left;
        cursor: pointer;
      }

      .option-card.muted {
        border-color: var(--stroke);
        color: var(--muted);
      }

      .option-thumb {
        height: 58px;
        border-radius: 10px;
        border: 1px solid var(--stroke);
        background: #0f1426;
        position: relative;
        overflow: hidden;
      }

      .option-thumb::after {
        content: "";
        position: absolute;
        inset: 8px;
        border-radius: 8px;
        border: 1px dashed rgba(0, 212, 255, 0.5);
      }

      .option-thumb.full::before {
        content: "";
        position: absolute;
        inset: 0;
        background: rgba(0, 212, 255, 0.12);
      }

      .option-thumb.top::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        height: 50%;
        background: rgba(0, 212, 255, 0.12);
      }

      .option-thumb.bottom::before {
        content: "";
        position: absolute;
        left: 0;
        bottom: 0;
        right: 0;
        height: 50%;
        background: rgba(0, 212, 255, 0.12);
      }

      .option-thumb.left::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 50%;
        background: rgba(0, 212, 255, 0.12);
      }

      .option-thumb.right::before {
        content: "";
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        width: 50%;
        background: rgba(0, 212, 255, 0.12);
      }

      .hidden {
        display: none !important;
      }

      /* iOS Save Modal Styles */
      .ios-save-card {
        width: min(420px, 95vw);
        max-height: 90vh;
        display: flex;
        flex-direction: column;
      }

      .ios-save-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding-bottom: 12px;
        border-bottom: 1px solid var(--stroke);
      }

      .ios-save-header h3 {
        margin: 0;
        font-size: 18px;
        color: var(--text);
      }

      .ios-close-btn {
        padding: 4px 10px;
        font-size: 16px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
      }

      .ios-save-image-container {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px 0;
        overflow: hidden;
      }

      .ios-save-image-container img {
        max-width: 100%;
        max-height: 55vh;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        object-fit: contain;
        -webkit-touch-callout: default !important;
        -webkit-user-select: auto !important;
        user-select: auto !important;
        pointer-events: auto !important;
        touch-action: auto !important;
      }

      .ios-save-instructions {
        text-align: center;
        padding: 16px;
        background: rgba(0, 212, 255, 0.08);
        border-radius: 12px;
        border: 1px solid rgba(0, 212, 255, 0.2);
      }

      .ios-save-icon {
        font-size: 32px;
        margin-bottom: 8px;
        animation: pulse 2s infinite;
      }

      .ios-save-instructions p {
        margin: 4px 0;
        color: var(--text);
        font-size: 14px;
        line-height: 1.4;
      }

      .ios-save-instructions strong {
        color: var(--accent-1);
      }

      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.1); }
      }

      /* Save button states */
      .save-btn {
        transition: all 0.2s ease;
      }

      .save-btn.saving {
        opacity: 0.7;
        pointer-events: none;
      }

      .save-btn.success {
        background: rgba(34, 197, 94, 0.8) !important;
      }

      .save-btn.error {
        background: rgba(239, 68, 68, 0.8) !important;
      }

      /* Toast notifications */
      .toast {
        position: fixed;
        bottom: 24px;
        left: 50%;
        transform: translateX(-50%) translateY(100px);
        background: rgba(14, 18, 32, 0.95);
        border: 1px solid var(--stroke);
        border-radius: 12px;
        padding: 16px 24px;
        color: var(--text);
        font-size: 14px;
        z-index: 1000;
        opacity: 0;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 10px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }

      .toast.show {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }

      .toast.success {
        border-color: rgba(34, 197, 94, 0.5);
      }

      .toast.error {
        border-color: rgba(239, 68, 68, 0.5);
      }

      .toast-icon {
        font-size: 20px;
      }

      /* iOS Batch Save Modal Styles */
      .ios-batch-save-card {
        width: min(420px, 95vw);
        max-height: 95vh;
        display: flex;
        flex-direction: column;
        padding: 20px;
      }

      .ios-batch-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--stroke);
        gap: 12px;
      }

      .ios-batch-header h3 {
        margin: 0;
        font-size: 17px;
        color: var(--text);
        flex: 1;
      }

      .ios-batch-counter {
        background: linear-gradient(135deg, var(--accent-1), var(--accent-2));
        color: var(--dark);
        padding: 6px 14px;
        border-radius: 20px;
        font-weight: 700;
        font-size: 15px;
      }

      .ios-batch-image-container {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px 0;
        min-height: 200px;
      }

      .ios-batch-image-container img {
        max-width: 100%;
        max-height: 45vh;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        -webkit-touch-callout: default !important;
        -webkit-user-select: auto !important;
        user-select: auto !important;
        pointer-events: auto !important;
      }

      .ios-batch-instructions {
        text-align: center;
        padding: 16px;
        background: rgba(0, 212, 255, 0.08);
        border-radius: 12px;
        border: 1px solid rgba(0, 212, 255, 0.2);
        margin-bottom: 16px;
      }

      .ios-batch-instructions p {
        margin: 6px 0;
        color: var(--text);
        font-size: 14px;
        line-height: 1.4;
      }

      .ios-batch-instructions strong {
        color: var(--accent-1);
      }

      .ios-batch-next-btn {
        width: 100%;
        padding: 14px 24px;
        font-size: 16px;
        font-weight: 700;
        border: none;
        border-radius: 12px;
        background: linear-gradient(135deg, var(--accent-1), #8bf0ff);
        color: #0b0f19;
        cursor: pointer;
        transition: all 0.2s;
      }

      .ios-batch-next-btn:active {
        transform: scale(0.98);
      }

      .ios-batch-done-btn {
        width: 100%;
        padding: 14px 24px;
        font-size: 16px;
        font-weight: 700;
        border: 1px solid rgba(34, 197, 94, 0.5);
        border-radius: 12px;
        background: rgba(34, 197, 94, 0.15);
        color: #22c55e;
        cursor: pointer;
        margin-top: 12px;
      }
    </style>
  </head>
  <body>
    <div class="page">
      <header>
        <h1>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫–∞—Ä—É—Å–µ–ª–µ–π –¥–ª—è Instagram</h1>
        <p>–°–æ–∑–¥–∞–≤–∞–π—Ç–µ –∫—Ä–∞—Å–∏–≤—ã–µ –∫–∞—Ä—É—Å–µ–ª–∏ –∑–∞ 3 –ø—Ä–æ—Å—Ç—ã—Ö —à–∞–≥–∞</p>
      </header>

      <!-- –®–∞–≥ 1 -->
      <section class="panel step-panel">
        <div class="step-header">
          <div class="step-number">1</div>
          <div class="step-title">–°–∫–æ–ø–∏—Ä—É–π –ø—Ä–æ–º–ø—Ç</div>
        </div>
        <p class="step-description">–ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–º–ø—Ç –¥–ª—è –ò–ò</p>
        <button class="primary" id="copyPromptBtn" style="height: 50px; font-size: 15px; padding: 0 22px; width: auto; display: inline-block; justify-self: start; background: linear-gradient(135deg, var(--accent-1), var(--accent-2));">üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–º–ø—Ç</button>
      </section>

      <!-- –®–∞–≥ 2 -->
      <section class="panel step-panel">
        <div class="step-header">
          <div class="step-number">2</div>
          <div class="step-title">–í—Å—Ç–∞–≤—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç –ò–ò –∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π</div>
        </div>
        <p class="step-description">–û—Ç–ø—Ä–∞–≤—å –ø—Ä–æ–º–ø—Ç –≤ –ª—é–±—É—é –Ω–µ–π—Ä–æ—Å–µ—Ç—å (ChatGPT, Claude, Gemini), –≤—Å—Ç–∞–≤—å –ø–æ–ª—É—á–µ–Ω–Ω—ã–π JSON –∏ –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É</p>
        <textarea id="jsonInput" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ JSON –æ—Ç –ò–ò –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ —Ç–µ–∫—Å—Ç –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏..."></textarea>
        <div class="step-header" style="margin-top: 16px;">
          <div class="step-number">3</div>
          <button class="primary" id="fromJsonBtn" style="height: 50px; font-size: 15px; padding: 0 22px; width: auto;">‚ú® –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–∞—Ä—É—Å–µ–ª—å</button>
        </div>
      </section>

      <!-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ -->
      <section class="panel controls">
        <div class="panel-head">
          <h3 style="margin: 0; font-size: 16px;">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è</h3>
        </div>
        <div class="row">
          <label class="meta">
            –†–µ–∂–∏–º:
            <select id="modeSelect">
              <option value="carousel" selected>–ö–∞—Ä—É—Å–µ–ª—å</option>
              <option value="cover">–û–±–ª–æ–∂–∫–∞</option>
            </select>
          </label>
          <label class="meta">
            –†–∞–∑–º–µ—Ä:
            <select id="sizeSelect">
              <option value="800x1000">800 √ó 1000</option>
              <option value="1080x1080">1080 √ó 1080</option>
              <option value="1080x1440">1080 √ó 1440</option>
              <option value="1080x1920">1080 √ó 1920</option>
              <option value="1350x1080">1350 √ó 1080</option>
            </select>
          </label>
          <label class="meta">
            –®—Ä–∏—Ñ—Ç:
            <select id="fontSelect">
              <option value="Golos Text">Golos Text</option>
              <option value="Manrope" selected>Manrope</option>
              <option value="Inter">Inter</option>
              <option value="Rubik">Rubik</option>
              <option value="Montserrat">Montserrat</option>
            </select>
          </label>
        </div>
        <div class="row">
          <div class="field" style="min-width: 100%">
            <label>–¢–µ–º–∞ (–∫–ª–∏–∫)</label>
            <div class="picker" id="layoutPicker">
              <button class="chip active" data-layout="line" type="button">
                <div class="layout-thumb" data-layout="line"></div>
                Line
              </button>
              <button class="chip" data-layout="frame" type="button">
                <div class="layout-thumb" data-layout="frame"></div>
                Frame
              </button>
              <button class="chip" data-layout="split" type="button">
                <div class="layout-thumb" data-layout="split"></div>
                Split
              </button>
              <button class="chip" data-layout="grid" type="button">
                <div class="layout-thumb" data-layout="grid"></div>
                Grid
              </button>
              <button class="chip" data-layout="pill" type="button">
                <div class="layout-thumb" data-layout="pill"></div>
                Pill
              </button>
              <button class="chip" data-layout="corner" type="button">
                <div class="layout-thumb" data-layout="corner"></div>
                Corner
              </button>
              <button class="chip" data-layout="dots" type="button">
                <div class="layout-thumb" data-layout="dots"></div>
                Dots
              </button>
              <button class="chip" data-layout="stripes" type="button">
                <div class="layout-thumb" data-layout="stripes"></div>
                Stripes
              </button>
              <button class="chip" data-layout="waves" type="button">
                <div class="layout-thumb" data-layout="waves"></div>
                Waves
              </button>
              <button class="chip" data-layout="circle" type="button">
                <div class="layout-thumb" data-layout="circle"></div>
                Circle
              </button>
              <button class="chip" data-layout="diamond" type="button">
                <div class="layout-thumb" data-layout="diamond"></div>
                Diamond
              </button>
              <button class="chip" data-layout="shadow" type="button">
                <div class="layout-thumb" data-layout="shadow"></div>
                Shadow
              </button>
              <button class="chip" data-layout="chat" type="button">
                <div class="layout-thumb" data-layout="chat"></div>
                –ß–∞—Ç
              </button>
              <button class="chip" data-layout="search" type="button">
                <div class="layout-thumb" data-layout="search"></div>
                –ü–æ–∏—Å–∫
              </button>
            </div>
          </div>
        </div>
        <div class="row">
          <div class="field" style="min-width: 100%">
            <label>–¶–≤–µ—Ç (–∫–ª–∏–∫)</label>
            <div class="picker" id="colorPicker">
              <button class="chip" data-palette="linen" type="button">
                <div class="color-thumb" data-palette="linen"></div>
                Linen
              </button>
              <button class="chip" data-palette="ice" type="button">
                <div class="color-thumb" data-palette="ice"></div>
                Ice
              </button>
              <button class="chip" data-palette="sand" type="button">
                <div class="color-thumb" data-palette="sand"></div>
                Sand
              </button>
              <button class="chip" data-palette="mint" type="button">
                <div class="color-thumb" data-palette="mint"></div>
                Mint
              </button>
              <button class="chip" data-palette="rose" type="button">
                <div class="color-thumb" data-palette="rose"></div>
                Rose
              </button>
              <button class="chip active" data-palette="midnight" type="button">
                <div class="color-thumb" data-palette="midnight"></div>
                Midnight
              </button>
              <button class="chip" data-palette="lavender" type="button">
                <div class="color-thumb" data-palette="lavender"></div>
                Lavender
              </button>
              <button class="chip" data-palette="sage" type="button">
                <div class="color-thumb" data-palette="sage"></div>
                Sage
              </button>
              <button class="chip" data-palette="coral" type="button">
                <div class="color-thumb" data-palette="coral"></div>
                Coral
              </button>
              <button class="chip" data-palette="white" type="button">
                <div class="color-thumb" data-palette="white"></div>
                White
              </button>
              <button class="chip" data-palette="black" type="button">
                <div class="color-thumb" data-palette="black"></div>
                Black
              </button>
            </div>
          </div>
        </div>
        <div class="row">
          <div class="field">
            <label for="ctaInput">–ü—Ä–∏–∑—ã–≤ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è (—Å—Å—ã–ª–∫–∞/–Ω–∏–∫)</label>
            <input id="ctaInput" type="text" placeholder="@username –∏–ª–∏ https://..." />
          </div>
          <div class="field">
            <label for="ctaTextInput">–¢–µ–∫—Å—Ç –ø—Ä–∏–∑—ã–≤–∞</label>
            <input id="ctaTextInput" type="text" value="–ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞" />
          </div>
          <div class="field" style="align-self: flex-end; margin-bottom: 2px;">
            <button id="applyCtaBtn" class="secondary" style="height: 40px;">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
          </div>
        </div>
        <div class="row">
          <div class="field" style="min-width: 100%">
            <label>–¶–≤–µ—Ç –ø–æ–¥–ª–æ–∂–∫–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞ (–ø—Ä–∏ —Ñ–æ—Ç–æ)</label>
            <div class="picker" id="underlayPicker">
              <button class="chip active" data-underlay="white" type="button">
                <div class="color-thumb" data-underlay="white"></div>
                White
              </button>
              <button class="chip" data-underlay="cream" type="button">
                <div class="color-thumb" data-underlay="cream"></div>
                Cream
              </button>
              <button class="chip" data-underlay="mist" type="button">
                <div class="color-thumb" data-underlay="mist"></div>
                Mist
              </button>
              <button class="chip" data-underlay="mint" type="button">
                <div class="color-thumb" data-underlay="mint"></div>
                Mint
              </button>
              <button class="chip" data-underlay="charcoal" type="button">
                <div class="color-thumb" data-underlay="charcoal"></div>
                Charcoal
              </button>
              <button class="chip" data-underlay="blush" type="button">
                <div class="color-thumb" data-underlay="blush"></div>
                Blush
              </button>
              <button class="chip" data-underlay="sky" type="button">
                <div class="color-thumb" data-underlay="sky"></div>
                Sky
              </button>
              <button class="chip" data-underlay="sand" type="button">
                <div class="color-thumb" data-underlay="sand"></div>
                Sand
              </button>
              <button class="chip" data-underlay="lavender" type="button">
                <div class="color-thumb" data-underlay="lavender"></div>
                Lavender
              </button>
              <button class="chip" data-underlay="peach" type="button">
                <div class="color-thumb" data-underlay="peach"></div>
                Peach
              </button>
              <button class="chip" data-underlay="sage" type="button">
                <div class="color-thumb" data-underlay="sage"></div>
                Sage
              </button>
              <button class="chip" data-underlay="coral" type="button">
                <div class="color-thumb" data-underlay="coral"></div>
                Coral
              </button>
            </div>
          </div>
        </div>
      </section>

      <!-- –†–µ–∑—É–ª—å—Ç–∞—Ç -->
      <section class="panel" id="resultsSection">
        <div class="panel-head" style="margin-bottom: 12px;">
          <h3 style="margin: 0; font-size: 16px;">–ì–æ—Ç–æ–≤—ã–µ —Å–ª–∞–π–¥—ã</h3>
          <div style="display: flex; gap: 8px;">
            <button class="zip" id="saveAllBtn" disabled style="display: none; padding: 6px 12px; background: linear-gradient(135deg, #22c55e, #16a34a); border: none; color: white; font-size: 14px;">
              üì≤ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—Å–µ
            </button>
            <button class="zip" id="downloadBtn" disabled style="display: none; padding: 6px 12px; background: linear-gradient(135deg, #8A2BE2, #6A0DAD); border: none; color: white; font-size: 14px;">
              üì¶ ZIP
            </button>
          </div>
        </div>
        <div id="slideOptions" class="row" style="margin-bottom: 16px; flex-wrap: wrap; gap: 16px; display: none;">
          <label class="meta" style="display: flex; align-items: center; gap: 8px;">
            –ü–æ–ª–æ–∂–µ–Ω–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–∞:
            <select id="titlePositionSelect" style="min-width: 140px;">
              <option value="center" selected>–ü–æ —Ü–µ–Ω—Ç—Ä—É</option>
              <option value="bottom-left">–í–Ω–∏–∑—É —Å–ª–µ–≤–∞</option>
              <option value="top-left">–í–≤–µ—Ä—Ö—É —Å–ª–µ–≤–∞</option>
            </select>
          </label>
          <label class="meta" style="display: flex; align-items: center; gap: 8px;">
            –ü–æ–¥–ª–æ–∂–∫–∞ —Ç–µ–∫—Å—Ç–∞:
            <select id="textUnderlaySelect" style="min-width: 160px;">
              <option value="none">–ë–µ–∑ –ø–æ–¥–ª–æ–∂–∫–∏</option>
              <option value="line" selected>–ü–æ–¥ –∫–∞–∂–¥—É—é —Å—Ç—Ä–æ–∫—É</option>
              <option value="card">–°–ø–ª–æ—à–Ω–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞</option>
            </select>
          </label>
        </div>
        <div class="preview-wrap">
          <div id="preview" class="preview-grid"></div>
          <div id="empty" class="empty">
            <div style="display: grid; gap: 12px; text-align: center;">
              <div style="font-size: 48px;">üé®</div>
              <div>–ó–¥–µ—Å—å –ø–æ—è–≤—è—Ç—Å—è –≤–∞—à–∏ —Å–ª–∞–π–¥—ã</div>
              <div style="font-size: 14px; opacity: 0.7;">–í—ã–ø–æ–ª–Ω–∏—Ç–µ 3 —à–∞–≥–∞ –≤—ã—à–µ</div>
            </div>
          </div>
        </div>
      </section>
    </div>

    <div class="modal" id="imageModal" aria-hidden="true">
      <div class="modal-card">
        <h3>–§–æ—Ç–æ –Ω–∞ —Å–ª–∞–π–¥</h3>
        <div class="option-grid">
          <button class="option-card" data-mode="full">
            <div class="option-thumb full"></div>
            –ù–∞ –≤–µ—Å—å —Å–ª–∞–π–¥
          </button>
          <button class="option-card" data-mode="top">
            <div class="option-thumb top"></div>
            –°–≤–µ—Ä—Ö—É 1/2
          </button>
          <button class="option-card" data-mode="bottom">
            <div class="option-thumb bottom"></div>
            –°–Ω–∏–∑—É 1/2
          </button>
          <button class="option-card" data-mode="left">
            <div class="option-thumb left"></div>
            –°–ª–µ–≤–∞ 1/2
          </button>
          <button class="option-card" data-mode="right">
            <div class="option-thumb right"></div>
            –°–ø—Ä–∞–≤–∞ 1/2
          </button>
          <button class="option-card muted" data-mode="remove">
            <div class="option-thumb"></div>
            –£–±—Ä–∞—Ç—å —Ñ–æ—Ç–æ
          </button>
        </div>
        <button class="ghost" id="closeModalBtn">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </div>

    <!-- iOS Save Modal -->
    <div class="modal" id="iosSaveModal" aria-hidden="true">
      <div class="modal-card ios-save-card">
        <div class="ios-save-header">
          <h3>–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ñ–æ—Ç–æ</h3>
          <button class="ghost ios-close-btn" id="closeIosModalBtn">‚úï</button>
        </div>
        <div class="ios-save-image-container">
          <img id="iosSaveImage" src="" alt="Slide" />
        </div>
        <div class="ios-save-instructions">
          <div class="ios-save-icon">üëÜ</div>
          <p><strong>–£–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ –ø–∞–ª–µ—Ü</strong> –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏</p>
          <p>–∏ –≤—ã–±–µ—Ä–∏—Ç–µ <strong>¬´–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –§–æ—Ç–æ¬ª</strong></p>
        </div>
      </div>
    </div>

    <!-- iOS Batch Save Modal -->
    <div class="modal" id="iosBatchSaveModal" aria-hidden="true">
      <div class="modal-card ios-batch-save-card">
        <div class="ios-batch-header">
          <h3>–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–µ—Ä–∏–∏ —Ñ–æ—Ç–æ</h3>
          <div class="ios-batch-counter">
            <span id="batchCurrent">1</span> / <span id="batchTotal">5</span>
          </div>
          <button class="ghost ios-close-btn" id="closeIosBatchModalBtn">‚úï</button>
        </div>
        <div class="ios-batch-image-container">
          <img id="iosBatchSaveImage" src="" alt="Slide" />
        </div>
        <div class="ios-batch-instructions">
          <div class="ios-save-icon">üëÜ</div>
          <p><strong>–®–∞–≥ 1:</strong> –£–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ –ø–∞–ª–µ—Ü –Ω–∞ —Ñ–æ—Ç–æ</p>
          <p><strong>–®–∞–≥ 2:</strong> –ù–∞–∂–º–∏—Ç–µ ¬´–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –§–æ—Ç–æ¬ª</p>
          <p><strong>–®–∞–≥ 3:</strong> –ù–∞–∂–º–∏—Ç–µ ¬´–î–∞–ª–µ–µ¬ª ‚Üì</p>
        </div>
        <button class="primary ios-batch-next-btn" id="iosBatchNextBtn">
          –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ ‚Üí –î–∞–ª–µ–µ
        </button>
        <button class="ghost ios-batch-done-btn hidden" id="iosBatchDoneBtn">
          ‚úÖ –ì–æ—Ç–æ–≤–æ! –ó–∞–∫—Ä—ã—Ç—å
        </button>
      </div>
    </div>

    <input id="slideImageInput" type="file" accept="image/*" style="display: none" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/heic-to@1.4.2/dist/iife/heic-to.js" crossorigin="anonymous"></script>
    <script>
      const jsonInput = document.getElementById("jsonInput");
      const modeSelect = document.getElementById("modeSelect");
      const sizeSelect = document.getElementById("sizeSelect");
      const fontSelect = document.getElementById("fontSelect");
      const underlayPicker = document.getElementById("underlayPicker");
      const layoutPicker = document.getElementById("layoutPicker");
      const colorPicker = document.getElementById("colorPicker");
      const fromJsonBtn = document.getElementById("fromJsonBtn");
      const downloadBtn = document.getElementById("downloadBtn");
      const saveAllBtn = document.getElementById("saveAllBtn");
      const copyPromptBtn = document.getElementById("copyPromptBtn");
      const preview = document.getElementById("preview");
      const empty = document.getElementById("empty");
      const ctaInput = document.getElementById("ctaInput");
      const ctaTextInput = document.getElementById("ctaTextInput");
      const imageModal = document.getElementById("imageModal");
      const closeModalBtn = document.getElementById("closeModalBtn");
      const slideImageInput = document.getElementById("slideImageInput");

      const state = {
        slides: [],
        size: { w: 1080, h: 1080 },
        title: "",
        fontFamily: "Manrope",
        mode: "carousel",
        underlay: "white",
        slideImages: {},
        pendingImageIndex: null,
        pendingImageMode: null,
        titlePosition: "center",
        textUnderlay: "line",
      };

      function isMobileDevice() {
        return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      }

      function isIOS() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      }

      // Check if Web Share API with files is supported
      function canShareFiles() {
        return navigator.share && navigator.canShare && typeof navigator.canShare === 'function';
      }

      // Save slide to gallery with optimal method based on device
      async function saveSlideToGallery(blob, filename, buttonElement = null) {
        // Update button state if provided
        if (buttonElement) {
          buttonElement.classList.add('saving');
          buttonElement.innerHTML = '‚è≥';
        }

        try {
          // Method 1: Web Share API (best for mobile - shows "Save Image" option)
          if (canShareFiles() && isMobileDevice()) {
            const file = new File([blob], filename, { type: 'image/jpeg' });
            const shareData = { files: [file] };

            if (navigator.canShare(shareData)) {
              await navigator.share(shareData);
              showToast('‚úÖ –û—Ç–∫—Ä–æ–π—Ç–µ –º–µ–Ω—é –∏ –≤—ã–±–µ—Ä–∏—Ç–µ ¬´–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ¬ª', 'success');
              if (buttonElement) {
                buttonElement.classList.remove('saving');
                buttonElement.classList.add('success');
                buttonElement.innerHTML = '‚úì';
                setTimeout(() => {
                  buttonElement.classList.remove('success');
                  buttonElement.innerHTML = 'üì•';
                }, 2000);
              }
              return true;
            }
          }

          // Method 2: iOS Long-Press Modal
          if (isIOS()) {
            const url = URL.createObjectURL(blob);
            const iosModal = document.getElementById('iosSaveModal');
            const iosImage = document.getElementById('iosSaveImage');

            iosImage.src = url;
            iosModal.classList.add('open');
            iosModal.setAttribute('aria-hidden', 'false');

            // Cleanup URL when modal closes
            const cleanup = () => {
              URL.revokeObjectURL(url);
              iosModal.removeEventListener('click', closeHandler);
            };

            const closeHandler = (e) => {
              if (e.target === iosModal || e.target.closest('.ios-close-btn')) {
                cleanup();
              }
            };

            iosModal.addEventListener('click', closeHandler);

            if (buttonElement) {
              buttonElement.classList.remove('saving');
              buttonElement.innerHTML = 'üì•';
            }
            return true;
          }

          // Method 3: Classic download (for Android and desktop)
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          // Delay cleanup for Android
          setTimeout(() => URL.revokeObjectURL(url), 1000);

          showToast('‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è...', 'success');

          if (buttonElement) {
            buttonElement.classList.remove('saving');
            buttonElement.classList.add('success');
            buttonElement.innerHTML = '‚úì';
            setTimeout(() => {
              buttonElement.classList.remove('success');
              buttonElement.innerHTML = 'üì•';
            }, 2000);
          }
          return true;

        } catch (error) {
          console.error('Save failed:', error);
          showToast('‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è', 'error');

          if (buttonElement) {
            buttonElement.classList.remove('saving');
            buttonElement.classList.add('error');
            buttonElement.innerHTML = '‚úï';
            setTimeout(() => {
              buttonElement.classList.remove('error');
              buttonElement.innerHTML = 'üì•';
            }, 2000);
          }
          return false;
        }
      }

      // Show toast notification
      function showToast(message, type = 'info') {
        // Remove existing toasts
        const existing = document.querySelector('.toast');
        if (existing) existing.remove();

        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.innerHTML = `<span class="toast-icon">${type === 'success' ? '‚úì' : type === 'error' ? '‚úï' : '‚ÑπÔ∏è'}</span><span>${message}</span>`;
        document.body.appendChild(toast);

        // Trigger animation
        requestAnimationFrame(() => toast.classList.add('show'));

        // Remove after delay
        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => toast.remove(), 300);
        }, 3000);
      }

      // Telegram Bot configuration
      const BOT_TOKEN = '8503919294:AAGaBNdKywlYwo9vAJA0VQNiO0PBBL4ccek';

      // Function to send images via Telegram Bot
      async function sendToTelegram(images) {
        // Get user ID from Telegram WebApp
        let userId = null;
        
        // Try to get from Telegram WebApp
        if (window.Telegram?.WebApp?.initDataUnsafe?.user?.id) {
          userId = window.Telegram.WebApp.initDataUnsafe.user.id;
        }
        
        // Fallback: try to parse from URL parameters
        if (!userId) {
          const urlParams = new URLSearchParams(window.location.search);
          const tgWebAppData = urlParams.get('tgWebAppData');
          if (tgWebAppData) {
            try {
              const parsed = JSON.parse(decodeURIComponent(tgWebAppData));
              userId = parsed.user?.id;
            } catch (e) {
              console.log('Could not parse tgWebAppData');
            }
          }
        }
        
        if (!userId) {
          // Not in Telegram WebApp - use fallback download
          console.log('Not in Telegram WebApp, using fallback download');
          return false;
        }

        // Show loading indicator
        const loadingMsg = document.createElement('div');
        loadingMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:white;padding:20px;border-radius:10px;z-index:9999;';
        loadingMsg.textContent = `–û—Ç–ø—Ä–∞–≤–∫–∞ 0/${images.length}...`;
        document.body.appendChild(loadingMsg);

        let sentCount = 0;
        const failed = [];

        for (let i = 0; i < images.length; i++) {
          const formData = new FormData();
          formData.append('chat_id', userId);
          formData.append('photo', images[i].blob, images[i].filename);
          
          try {
            const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
              method: 'POST',
              body: formData
            });
            
            const result = await response.json();
            
            if (result.ok) {
              sentCount++;
              loadingMsg.textContent = `–û—Ç–ø—Ä–∞–≤–∫–∞ ${sentCount}/${images.length}...`;
            } else {
              console.error('Telegram API error:', result);
              failed.push(i + 1);
            }
          } catch (err) {
            console.error('Send failed:', err);
            failed.push(i + 1);
          }
          
          // Delay between sends (avoid rate limiting)
          if (i < images.length - 1) {
            await new Promise(r => setTimeout(r, 1500));
          }
        }
        
        document.body.removeChild(loadingMsg);
        
        if (failed.length === 0) {
          alert(`‚úÖ –í—Å–µ ${images.length} —Å–ª–∞–π–¥–æ–≤ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –≤ Telegram!`);
        } else {
          alert(`‚ö†Ô∏è –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ ${sentCount} –∏–∑ ${images.length}\n–ù–µ —É–¥–∞–ª–æ—Å—å: —Å–ª–∞–π–¥—ã ‚Ññ${failed.join(', ')}`);
        }
        
        return failed.length === 0;
      }

      const palettes = {
        linen: {
          bgLight: "#fbf8f3",
          bgDark: "#141724",
          text: "#11131f",
          muted: "rgba(17, 19, 31, 0.55)",
          accents: ["#2f80ed", "#f2c14e", "#0fa3b1", "#f26419"],
        },
        ice: {
          bgLight: "#f3f7fb",
          bgDark: "#12151f",
          text: "#10121a",
          muted: "rgba(16, 18, 26, 0.55)",
          accents: ["#3a86ff", "#4cc9f0", "#5e60ce", "#72efdd"],
        },
        sand: {
          bgLight: "#fbf6ee",
          bgDark: "#18130f",
          text: "#17120f",
          muted: "rgba(23, 18, 15, 0.55)",
          accents: ["#b5651d", "#e09f3e", "#9b2226", "#6f1d1b"],
        },
        mint: {
          bgLight: "#f2fbf7",
          bgDark: "#0f1a16",
          text: "#0f1a16",
          muted: "rgba(15, 26, 22, 0.55)",
          accents: ["#2d9cdb", "#27ae60", "#6fcf97", "#16a085"],
        },
        rose: {
          bgLight: "#fff5f7",
          bgDark: "#1c1115",
          text: "#1c1115",
          muted: "rgba(28, 17, 21, 0.55)",
          accents: ["#ff5d8f", "#f28482", "#f6bd60", "#9b5de5"],
        },
        midnight: {
          bgLight: "#f4f6fb",
          bgDark: "#0b1020",
          text: "#0b1020",
          muted: "rgba(11, 16, 32, 0.55)",
          accents: ["#3f37c9", "#4895ef", "#4cc9f0", "#b5179e"],
        },
        lavender: {
          bgLight: "#f8f5ff",
          bgDark: "#1a1525",
          text: "#1a1525",
          muted: "rgba(26, 21, 37, 0.55)",
          accents: ["#9d4edd", "#c77dff", "#e0aaff", "#7b2cbf"],
        },
        sage: {
          bgLight: "#f5f7f4",
          bgDark: "#151916",
          text: "#151916",
          muted: "rgba(21, 25, 22, 0.55)",
          accents: ["#7d8b74", "#9caf88", "#5c6b52", "#8fbc8f"],
        },
        coral: {
          bgLight: "#fff5f3",
          bgDark: "#241814",
          text: "#241814",
          muted: "rgba(36, 24, 20, 0.55)",
          accents: ["#ff6b6b", "#f06595", "#fa5252", "#e64980"],
        },
        white: {
          bgLight: "#ffffff",
          bgDark: "#0a0a0a",
          text: "#0a0a0a",
          muted: "rgba(10, 10, 10, 0.55)",
          accents: ["#3b82f6", "#8b5cf6", "#10b981", "#f59e0b"],
        },
        black: {
          bgLight: "#0f0f0f",
          bgDark: "#ffffff",
          text: "#ffffff",
          muted: "rgba(255, 255, 255, 0.6)",
          accents: ["#60a5fa", "#a78bfa", "#34d399", "#fbbf24"],
        },
      };

      const underlays = {
        white: { color: "rgba(255, 255, 255, 0.98)", text: "#11131f" },
        cream: { color: "rgba(255, 247, 232, 0.98)", text: "#17120f" },
        mist: { color: "rgba(238, 243, 255, 0.98)", text: "#10121a" },
        mint: { color: "rgba(238, 250, 244, 0.98)", text: "#0f1a16" },
        charcoal: { color: "rgba(20, 24, 32, 0.92)", text: "#f4f6fb" },
        blush: { color: "rgba(255, 240, 245, 0.98)", text: "#1c1115" },
        sky: { color: "rgba(224, 242, 254, 0.98)", text: "#0c4a6e" },
        sand: { color: "rgba(254, 252, 232, 0.98)", text: "#422006" },
        lavender: { color: "rgba(243, 232, 255, 0.98)", text: "#581c87" },
        peach: { color: "rgba(255, 237, 213, 0.98)", text: "#7c2d12" },
        sage: { color: "rgba(220, 252, 231, 0.98)", text: "#14532d" },
        coral: { color: "rgba(254, 226, 226, 0.98)", text: "#7f1d1d" },
      };

      const layouts = {
        line: "line",
        frame: "frame",
        split: "split",
        grid: "grid",
        pill: "pill",
        corner: "corner",
        dots: "dots",
        stripes: "stripes",
        waves: "waves",
        circle: "circle",
        diamond: "diamond",
        shadow: "shadow",
        chat: "chat",
        search: "search",
      };

      function parseSize(value) {
        const [w, h] = value.split("x").map(Number);
        return { w, h };
      }

      function parseStyledSegments(text) {
        const segments = [];
        let buf = "";
        let mode = "normal"; // normal | accent | bold | header
        let i = 0;

        const flush = () => {
          if (buf) segments.push({ text: buf, mode });
          buf = "";
        };

        while (i < text.length) {
          const ch = text[i];
          const rest = text.slice(i);

          if (rest.startsWith("<accent>")) {
            flush();
            mode = "accent";
            i += 8;
            continue;
          }

          if (rest.startsWith("</accent>")) {
            flush();
            mode = "normal";
            i += 9;
            continue;
          }

          if (rest.startsWith("<bold>")) {
            flush();
            mode = "bold";
            i += 6;
            continue;
          }

          if (rest.startsWith("</bold>")) {
            flush();
            mode = "normal";
            i += 7;
            continue;
          }

          if (rest.startsWith("<header>")) {
            flush();
            mode = "header";
            i += 8;
            continue;
          }

          if (rest.startsWith("</header>")) {
            flush();
            mode = "normal";
            i += 9;
            // Add line break after header (new line without empty spacing)
            segments.push({ text: "__LINEBREAK__", mode: "normal", isBreak: true });
            continue;
          }

          buf += ch;
          i += 1;
        }

        flush();
        return segments;
      }

      function segmentsToWords(segments) {
        const words = [];
        const stickToPrev = /^(?:[,.!:;?)]|[¬ª"]|‚Ä¶)+$/;
        segments.forEach((seg) => {
          if (seg.isBreak) {
            // Add a special break word
            words.push({
              text: "__LINEBREAK__",
              mode: seg.mode,
              isBreak: true,
              noSpaceBefore: true,
            });
          } else {
            const parts = seg.text.split(/\s+/).filter(Boolean);
            parts.forEach((word) =>
              words.push({
                text: word,
                mode: seg.mode,
                noSpaceBefore: stickToPrev.test(word),
              })
            );
          }
        });
        return words;
      }

      function fontWeightFor(mode, isTitle) {
        if (mode === "bold") return 800;
        if (mode === "accent") return 700;
        if (mode === "header") return 800;
        return isTitle ? 800 : 600;
      }

      function buildLinesFromWords(ctx, words, maxWidth, fontSize, fontFamily, isTitle) {
        const lines = [];
        let lineWords = [];
        let lineWidth = 0;
        const spaceWidth = ctx.measureText(" ").width;

        words.forEach((word) => {
          // Handle line break - just end current line, no empty line
          if (word.isBreak) {
            if (lineWords.length) {
              lines.push({ words: lineWords, width: lineWidth });
              lineWords = [];
              lineWidth = 0;
            }
            return;
          }
          
          const weight = fontWeightFor(word.mode, isTitle);
          // Header words are 1.3x larger
          const wordFontSize = word.mode === "header" ? Math.round(fontSize * 1.3) : fontSize;
          ctx.font = `${weight} ${wordFontSize}px "${fontFamily}", sans-serif`;
          const wordWidth = ctx.measureText(word.text).width;
          const extra = lineWords.length && !word.noSpaceBefore ? spaceWidth : 0;
          if (lineWidth + extra + wordWidth <= maxWidth || !lineWords.length) {
            lineWords.push({ ...word, width: wordWidth, weight });
            lineWidth += extra + wordWidth;
          } else {
            lines.push({ words: lineWords, width: lineWidth });
            lineWords = [{ ...word, width: wordWidth, weight }];
            lineWidth = wordWidth;
          }
        });

        if (lineWords.length) {
          lines.push({ words: lineWords, width: lineWidth });
        }
        return lines;
      }

      function pickAccent(text) {
        const pool = state.palette.accents;
        if (!pool || !pool.length) return "#2f80ed";
        let hash = 0;
        for (let i = 0; i < text.length; i++) {
          hash = (hash * 31 + text.charCodeAt(i)) >>> 0;
        }
        return pool[hash % pool.length];
      }

      function drawCoverImage(ctx, img, w, h) {
        const scale = Math.max(w / img.width, h / img.height);
        const drawW = img.width * scale;
        const drawH = img.height * scale;
        const dx = (w - drawW) / 2;
        const dy = (h - drawH) / 2;
        ctx.drawImage(img, dx, dy, drawW, drawH);
      }

      function drawCoverImageInRect(ctx, img, rect) {
        const scale = Math.max(rect.w / img.width, rect.h / img.height);
        const drawW = img.width * scale;
        const drawH = img.height * scale;
        const dx = rect.x + (rect.w - drawW) / 2;
        const dy = rect.y + (rect.h - drawH) / 2;
        ctx.save();
        ctx.beginPath();
        ctx.rect(rect.x, rect.y, rect.w, rect.h);
        ctx.clip();
        ctx.drawImage(img, dx, dy, drawW, drawH);
        ctx.restore();
      }

      function getImageRect(mode, w, h) {
        if (mode === "top") return { x: 0, y: 0, w, h: h / 2 };
        if (mode === "bottom") return { x: 0, y: h / 2, w, h: h / 2 };
        if (mode === "left") return { x: 0, y: 0, w: w / 2, h };
        if (mode === "right") return { x: w / 2, y: 0, w: w / 2, h };
        return { x: 0, y: 0, w, h };
      }

      function drawImageModeHint(ctx, rect, label, accent) {
        ctx.save();
        ctx.strokeStyle = `${accent}88`;
        ctx.lineWidth = Math.max(2, Math.round(Math.min(rect.w, rect.h) * 0.01));
        ctx.setLineDash([8, 6]);
        ctx.strokeRect(rect.x + 6, rect.y + 6, rect.w - 12, rect.h - 12);
        ctx.setLineDash([]);

        const badgePaddingX = 10;
        const badgePaddingY = 6;
        ctx.font = `600 ${Math.max(12, Math.round(Math.min(rect.w, rect.h) * 0.04))}px "Manrope", sans-serif`;
        const textW = ctx.measureText(label).width;
        const badgeW = textW + badgePaddingX * 2;
        const badgeH = Math.max(20, Math.round(Math.min(rect.w, rect.h) * 0.08));
        const bx = rect.x + rect.w - badgeW - 12;
        const by = rect.y + 12;
        ctx.fillStyle = "rgba(11, 16, 32, 0.65)";
        ctx.beginPath();
        ctx.roundRect(bx, by, badgeW, badgeH, Math.round(badgeH / 2));
        ctx.fill();

        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.fillText(label, bx + badgePaddingX, by + badgeH / 2);
        ctx.restore();
      }

      function drawSlide(canvas, text, index, total, isTitle, slideImage, isCta = false) {
        const { w, h } = state.size;
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d");
        
        // Declare accent at the beginning for use throughout the function
        const accent = pickAccent(state.title || text);

        // Background
        if (slideImage && slideImage.mode === "full") {
          drawCoverImage(ctx, slideImage.img, w, h);
          if (isTitle) {
            ctx.fillStyle = "rgba(255, 255, 255, 0.10)";
            ctx.fillRect(0, 0, w, h);
          }
        } else {
          ctx.fillStyle = state.palette.bgLight;
          ctx.fillRect(0, 0, w, h);
        }

        // Apply the same radial gradient to all slides (including CTA)
        const gradient = ctx.createRadialGradient(w * 0.2, h * 0.15, 10, w * 0.2, h * 0.15, w * 0.9);
        gradient.addColorStop(0, `${accent}1A`);
        gradient.addColorStop(1, `${accent}10`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, w, h);

        if (state.layout === layouts.line) {
          ctx.fillStyle = state.palette.bgDark;
          ctx.fillRect(w * 0.08, h * 0.08, w * 0.16, 6);
          ctx.beginPath();
          ctx.arc(w * 0.26, h * 0.083, 5, 0, Math.PI * 2);
          ctx.fill();
        } else if (state.layout === layouts.frame) {
          ctx.strokeStyle = `${accent}55`;
          ctx.lineWidth = Math.max(2, Math.round(w * 0.004));
          ctx.strokeRect(w * 0.07, h * 0.07, w * 0.86, h * 0.86);
        } else if (state.layout === layouts.split) {
          ctx.fillStyle = `${accent}22`;
          ctx.fillRect(0, 0, w * 0.32, h);
          ctx.fillStyle = state.palette.bgDark;
          ctx.fillRect(w * 0.08, h * 0.12, w * 0.1, 6);
        } else if (state.layout === layouts.grid) {
          ctx.strokeStyle = `${accent}33`;
          ctx.lineWidth = 1;
          const step = Math.max(24, Math.round(w * 0.06));
          for (let x = step; x < w; x += step) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
            ctx.stroke();
          }
          for (let y = step; y < h; y += step) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(w, y);
            ctx.stroke();
          }
        } else if (state.layout === layouts.pill) {
          ctx.fillStyle = `${accent}26`;
          const pillW = w * 0.38;
          const pillH = h * 0.08;
          const pillX = w * 0.08;
          const pillY = h * 0.08;
          ctx.beginPath();
          ctx.roundRect(pillX, pillY, pillW, pillH, pillH / 2);
          ctx.fill();
        } else if (state.layout === layouts.corner) {
          ctx.fillStyle = `${accent}28`;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(w * 0.25, 0);
          ctx.lineTo(0, h * 0.18);
          ctx.closePath();
          ctx.fill();
        } else if (state.layout === layouts.dots) {
          ctx.fillStyle = `${accent}40`;
          const dotSize = Math.max(4, Math.round(w * 0.012));
          const spacing = Math.max(20, Math.round(w * 0.05));
          for (let x = w * 0.08; x < w * 0.25; x += spacing) {
            for (let y = h * 0.08; y < h * 0.25; y += spacing) {
              ctx.beginPath();
              ctx.arc(x, y, dotSize / 2, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        } else if (state.layout === layouts.stripes) {
          ctx.fillStyle = `${accent}20`;
          const stripeWidth = Math.max(3, Math.round(w * 0.008));
          const stripeGap = stripeWidth * 2;
          for (let x = w * 0.05; x < w * 0.35; x += stripeGap) {
            ctx.fillRect(x, h * 0.05, stripeWidth, h * 0.25);
          }
        } else if (state.layout === layouts.waves) {
          ctx.fillStyle = `${accent}25`;
          ctx.beginPath();
          ctx.moveTo(0, h * 0.85);
          for (let x = 0; x <= w; x += w / 20) {
            ctx.lineTo(x, h * 0.85 + Math.sin(x / w * Math.PI * 2) * h * 0.05);
          }
          ctx.lineTo(w, h);
          ctx.lineTo(0, h);
          ctx.closePath();
          ctx.fill();
        } else if (state.layout === layouts.circle) {
          ctx.strokeStyle = `${accent}50`;
          ctx.lineWidth = Math.max(2, Math.round(w * 0.004));
          ctx.beginPath();
          ctx.arc(w * 0.85, h * 0.15, w * 0.08, 0, Math.PI * 2);
          ctx.stroke();
        } else if (state.layout === layouts.diamond) {
          ctx.fillStyle = `${accent}30`;
          const size = w * 0.06;
          ctx.save();
          ctx.translate(w * 0.9, h * 0.1);
          ctx.rotate(Math.PI / 4);
          ctx.fillRect(-size / 2, -size / 2, size, size);
          ctx.restore();
        } else if (state.layout === layouts.shadow) {
          ctx.fillStyle = `${accent}15`;
          const offset = w * 0.02;
          ctx.fillRect(w * 0.08 + offset, h * 0.08 + offset, w * 0.2, h * 0.12);
          ctx.fillStyle = `${accent}30`;
          ctx.fillRect(w * 0.08, h * 0.08, w * 0.2, h * 0.12);
        } else if (state.layout === layouts.chat) {
          // iMessage-style chat bubbles
          const bubbleColor = "#007aff";
          const bubbleReceived = "#e5e5ea";
          // Sent bubble (right side)
          ctx.fillStyle = bubbleColor;
          const sentW = w * 0.5;
          const sentH = h * 0.12;
          const sentX = w * 0.45;
          const sentY = h * 0.15;
          ctx.beginPath();
          ctx.roundRect(sentX, sentY, sentW, sentH, sentH * 0.2);
          ctx.fill();
          // Tail for sent bubble
          ctx.beginPath();
          ctx.moveTo(sentX + sentW - sentH * 0.1, sentY + sentH);
          ctx.lineTo(sentX + sentW + sentH * 0.15, sentY + sentH + sentH * 0.3);
          ctx.lineTo(sentX + sentW - sentH * 0.3, sentY + sentH);
          ctx.closePath();
          ctx.fill();
          // Received bubble (left side)
          ctx.fillStyle = bubbleReceived;
          const recW = w * 0.42;
          const recH = h * 0.1;
          const recX = w * 0.08;
          const recY = h * 0.32;
          ctx.beginPath();
          ctx.roundRect(recX, recY, recW, recH, recH * 0.2);
          ctx.fill();
          // Tail for received bubble
          ctx.beginPath();
          ctx.moveTo(recX + recH * 0.1, recY + recH);
          ctx.lineTo(recX - recH * 0.15, recY + recH + recH * 0.3);
          ctx.lineTo(recX + recH * 0.3, recY + recH);
          ctx.closePath();
          ctx.fill();
        } else if (state.layout === layouts.search) {
          // Google search bar style
          ctx.fillStyle = "#f1f3f4";
          const searchBarH = h * 0.08;
          const searchBarY = h * 0.06;
          ctx.beginPath();
          ctx.roundRect(w * 0.06, searchBarY, w * 0.88, searchBarH, searchBarH / 2);
          ctx.fill();
          // Search icon (magnifying glass)
          ctx.strokeStyle = "#9aa0a6";
          ctx.lineWidth = Math.max(2, Math.round(w * 0.004));
          const iconX = w * 0.1;
          const iconY = searchBarY + searchBarH / 2;
          ctx.beginPath();
          ctx.arc(iconX, iconY - 2, searchBarH * 0.2, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(iconX + searchBarH * 0.15, iconY + searchBarH * 0.1);
          ctx.lineTo(iconX + searchBarH * 0.35, iconY + searchBarH * 0.3);
          ctx.stroke();
          // Google dots decoration
          const colors = ["#4285f4", "#ea4335", "#fbbc05", "#34a853"];
          const dotY = h * 0.25;
          colors.forEach((color, i) => {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(w * 0.3 + i * w * 0.08, dotY, w * 0.02, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        // CTA Slide - Same layout as other slides
        if (isCta) {
          // Use the same accent as calculated at the beginning of the function
          // Apply layout based on selected theme (same as other slides)
          if (state.layout === layouts.line) {
            ctx.fillStyle = state.palette.bgDark;
            ctx.fillRect(w * 0.08, h * 0.08, w * 0.16, 6);
            ctx.beginPath();
            ctx.arc(w * 0.26, h * 0.083, 5, 0, Math.PI * 2);
            ctx.fill();
          } else if (state.layout === layouts.frame) {
            ctx.strokeStyle = `${accent}55`;
            ctx.lineWidth = Math.max(2, Math.round(w * 0.004));
            ctx.strokeRect(w * 0.07, h * 0.07, w * 0.86, h * 0.86);
          } else if (state.layout === layouts.split) {
            ctx.fillStyle = `${accent}22`;
            ctx.fillRect(0, 0, w * 0.32, h);
            ctx.fillStyle = state.palette.bgDark;
            ctx.fillRect(w * 0.08, h * 0.12, w * 0.1, 6);
          } else if (state.layout === layouts.grid) {
            ctx.strokeStyle = `${accent}33`;
            ctx.lineWidth = 1;
            const step = Math.max(24, Math.round(w * 0.06));
            for (let x = step; x < w; x += step) {
              ctx.beginPath();
              ctx.moveTo(x, 0);
              ctx.lineTo(x, h);
              ctx.stroke();
            }
            for (let y = step; y < h; y += step) {
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(w, y);
              ctx.stroke();
            }
          } else if (state.layout === layouts.pill) {
            ctx.fillStyle = `${accent}26`;
            const pillW = w * 0.38;
            const pillH = h * 0.08;
            const pillX = w * 0.08;
            const pillY = h * 0.08;
            ctx.beginPath();
            ctx.roundRect(pillX, pillY, pillW, pillH, pillH / 2);
            ctx.fill();
          } else if (state.layout === layouts.corner) {
            ctx.fillStyle = `${accent}28`;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(w * 0.25, 0);
            ctx.lineTo(0, h * 0.18);
            ctx.closePath();
            ctx.fill();
          } else if (state.layout === layouts.dots) {
            ctx.fillStyle = `${accent}40`;
            const dotSize = Math.max(4, Math.round(w * 0.012));
            const spacing = Math.max(20, Math.round(w * 0.05));
            for (let x = w * 0.08; x < w * 0.25; x += spacing) {
              for (let y = h * 0.08; y < h * 0.25; y += spacing) {
                ctx.beginPath();
                ctx.arc(x, y, dotSize / 2, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          } else if (state.layout === layouts.stripes) {
            ctx.fillStyle = `${accent}20`;
            const stripeWidth = Math.max(3, Math.round(w * 0.008));
            const stripeGap = stripeWidth * 2;
            for (let x = w * 0.05; x < w * 0.35; x += stripeGap) {
              ctx.fillRect(x, h * 0.05, stripeWidth, h * 0.25);
            }
          } else if (state.layout === layouts.waves) {
            ctx.fillStyle = `${accent}25`;
            ctx.beginPath();
            ctx.moveTo(0, h * 0.85);
            for (let x = 0; x <= w; x += w / 20) {
              ctx.lineTo(x, h * 0.85 + Math.sin(x / w * Math.PI * 2) * h * 0.05);
            }
            ctx.lineTo(w, h);
            ctx.lineTo(0, h);
            ctx.closePath();
            ctx.fill();
          } else if (state.layout === layouts.circle) {
            ctx.strokeStyle = `${accent}50`;
            ctx.lineWidth = Math.max(2, Math.round(w * 0.004));
            ctx.beginPath();
            ctx.arc(w * 0.85, h * 0.15, w * 0.08, 0, Math.PI * 2);
            ctx.stroke();
          } else if (state.layout === layouts.diamond) {
            ctx.fillStyle = `${accent}30`;
            const size = w * 0.06;
            ctx.save();
            ctx.translate(w * 0.9, h * 0.1);
            ctx.rotate(Math.PI / 4);
            ctx.fillRect(-size / 2, -size / 2, size, size);
            ctx.restore();
          } else if (state.layout === layouts.shadow) {
            ctx.fillStyle = `${accent}15`;
            const offset = w * 0.02;
            ctx.fillRect(w * 0.08 + offset, h * 0.08 + offset, w * 0.2, h * 0.12);
            ctx.fillStyle = `${accent}30`;
            ctx.fillRect(w * 0.08, h * 0.08, w * 0.2, h * 0.12);
          } else if (state.layout === layouts.chat) {
            // iMessage-style chat bubbles with text
            const paragraphs = text.split(/\n\n+|\n/).filter(p => p.trim());
            const sentText = paragraphs[0] || text;
            const receivedText = paragraphs[1] || '';
            
            // Sent bubble (right side, blue)
            const bubbleColor = "#007aff";
            const bubbleReceived = "#e5e5ea";
            const padding = w * 0.03;
            const maxBubbleWidth = w * 0.72;
            const minFont = Math.round(Math.min(w, h) * 0.025);
            
            // Calculate sent bubble dimensions with auto-scale
            let sentFontSize = Math.round(Math.min(w, h) * 0.038);
            let sentLines = [];
            let sentBubbleWidth, sentBubbleHeight;
            
            ctx.font = `400 ${sentFontSize}px "Manrope", sans-serif`;
            while (sentFontSize >= minFont) {
              const segments = parseStyledSegments(sentText);
              const words = segmentsToWords(segments);
              sentLines = buildLinesFromWords(ctx, words, maxBubbleWidth - padding * 2, sentFontSize, "Manrope", false);
              const lineHeight = sentFontSize * 1.25;
              sentBubbleHeight = sentLines.length * lineHeight + padding * 2;
              sentBubbleWidth = Math.min(maxBubbleWidth, Math.max(...sentLines.map(l => l.width)) + padding * 2);
              if (sentBubbleHeight <= h * 0.35) break;
              sentFontSize -= 2;
              ctx.font = `400 ${sentFontSize}px "Manrope", sans-serif`;
            }
            
            const sentX = w - w * 0.06 - sentBubbleWidth;
            const sentY = h * 0.12;
            
            // Draw sent bubble
            ctx.fillStyle = bubbleColor;
            ctx.beginPath();
            ctx.roundRect(sentX, sentY, sentBubbleWidth, sentBubbleHeight, sentFontSize * 0.4);
            ctx.fill();
            // Tail for sent bubble
            ctx.beginPath();
            ctx.moveTo(sentX + sentBubbleWidth - sentFontSize * 0.3, sentY + sentBubbleHeight);
            ctx.lineTo(sentX + sentBubbleWidth + sentFontSize * 0.2, sentY + sentBubbleHeight + sentFontSize * 0.5);
            ctx.lineTo(sentX + sentBubbleWidth - sentFontSize * 0.6, sentY + sentBubbleHeight);
            ctx.closePath();
            ctx.fill();
            
            // Draw sent text
            ctx.fillStyle = "#ffffff";
            ctx.textBaseline = "top";
            const lineHeight = sentFontSize * 1.25;
            let y = sentY + padding + (sentBubbleHeight - padding * 2 - sentLines.length * lineHeight) / 2;
            const spaceWidth = ctx.measureText(" ").width;
            
            sentLines.forEach((line) => {
              let x = sentX + padding;
              line.words.forEach((word, idx) => {
                ctx.font = `${word.weight} ${sentFontSize}px "Manrope", sans-serif`;
                if (idx > 0 && !word.noSpaceBefore) {
                  x += spaceWidth;
                }
                ctx.fillText(word.text, x, y);
                x += word.width;
              });
              y += lineHeight;
            });
            
            // Received bubble (left side, gray)
            if (receivedText) {
              let recFontSize = Math.round(Math.min(w, h) * 0.035);
              let recLines = [];
              let recBubbleWidth, recBubbleHeight;
              
              ctx.font = `400 ${recFontSize}px "Manrope", sans-serif`;
              while (recFontSize >= minFont) {
                const segments = parseStyledSegments(receivedText);
                const words = segmentsToWords(segments);
                recLines = buildLinesFromWords(ctx, words, maxBubbleWidth - padding * 2, recFontSize, "Manrope", false);
                const recLineHeight = recFontSize * 1.25;
                recBubbleHeight = recLines.length * recLineHeight + padding * 2;
                recBubbleWidth = Math.min(maxBubbleWidth, Math.max(...recLines.map(l => l.width)) + padding * 2);
                if (recBubbleHeight <= h * 0.3) break;
                recFontSize -= 2;
                ctx.font = `400 ${recFontSize}px "Manrope", sans-serif`;
              }
              
              const recX = w * 0.06;
              const recY = sentY + sentBubbleHeight + h * 0.04;
              
              // Draw received bubble
              ctx.fillStyle = bubbleReceived;
              ctx.beginPath();
              ctx.roundRect(recX, recY, recBubbleWidth, recBubbleHeight, recFontSize * 0.4);
              ctx.fill();
              // Tail for received bubble
              ctx.beginPath();
              ctx.moveTo(recX + recFontSize * 0.3, recY + recBubbleHeight);
              ctx.lineTo(recX - recFontSize * 0.2, recY + recBubbleHeight + recFontSize * 0.5);
              ctx.lineTo(recX + recFontSize * 0.6, recY + recBubbleHeight);
              ctx.closePath();
              ctx.fill();
              
              // Draw received text
              ctx.fillStyle = "#000000";
              const recLineHeight = recFontSize * 1.25;
              y = recY + padding + (recBubbleHeight - padding * 2 - recLines.length * recLineHeight) / 2;
              
              recLines.forEach((line) => {
                let x = recX + padding;
                line.words.forEach((word, idx) => {
                  ctx.font = `${word.weight} ${recFontSize}px "Manrope", sans-serif`;
                  if (idx > 0 && !word.noSpaceBefore) {
                    x += spaceWidth;
                  }
                  ctx.fillText(word.text, x, y);
                  x += word.width;
                });
                y += recLineHeight;
              });
            }
          } else if (state.layout === layouts.search) {
            // Google search bar style with text
            const paragraphs = text.split(/\n\n+|\n/).filter(p => p.trim());
            const searchQuery = paragraphs[0] || text;
            const answerText = paragraphs.slice(1).join('\n') || '';
            
            // Search bar background
            ctx.fillStyle = "#f1f3f4";
            const searchBarH = h * 0.1;
            const searchBarY = h * 0.08;
            ctx.beginPath();
            ctx.roundRect(w * 0.06, searchBarY, w * 0.88, searchBarH, searchBarH / 2);
            ctx.fill();
            
            // Search icon (magnifying glass)
            ctx.strokeStyle = "#9aa0a6";
            ctx.lineWidth = Math.max(2, Math.round(w * 0.004));
            const iconX = w * 0.1;
            const iconY = searchBarY + searchBarH / 2;
            ctx.beginPath();
            ctx.arc(iconX, iconY - 2, searchBarH * 0.18, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(iconX + searchBarH * 0.12, iconY + searchBarH * 0.08);
            ctx.lineTo(iconX + searchBarH * 0.32, iconY + searchBarH * 0.28);
            ctx.stroke();
            
            // Search query text (auto-scale)
            ctx.fillStyle = "#202124";
            ctx.textBaseline = "middle";
            let searchFontSize = Math.round(searchBarH * 0.35);
            const searchTextX = w * 0.16;
            const maxSearchWidth = w * 0.76;
            ctx.font = `400 ${searchFontSize}px "Manrope", sans-serif`;
            while (ctx.measureText(searchQuery).width > maxSearchWidth && searchFontSize > 12) {
              searchFontSize -= 2;
              ctx.font = `400 ${searchFontSize}px "Manrope", sans-serif`;
            }
            ctx.fillText(searchQuery, searchTextX, searchBarY + searchBarH / 2);
            
            // Answer text block
            if (answerText) {
              const answerY = h * 0.22;
              const answerMaxWidth = w * 0.88;
              const answerMaxHeight = h * 0.65;
              
              ctx.fillStyle = "#202124";
              ctx.textBaseline = "top";
              let answerFontSize = Math.round(Math.min(w, h) * 0.045);
              const minAnswerFont = Math.round(Math.min(w, h) * 0.028);
              
              let answerLines = [];
              while (answerFontSize >= minAnswerFont) {
                ctx.font = `500 ${answerFontSize}px "Manrope", sans-serif`;
                const segments = parseStyledSegments(answerText);
                const words = segmentsToWords(segments);
                answerLines = buildLinesFromWords(ctx, words, answerMaxWidth, answerFontSize, "Manrope", false);
                const lineHeight = answerFontSize * 1.3;
                if (answerLines.length * lineHeight <= answerMaxHeight) break;
                answerFontSize -= 2;
              }
              
              const lineHeight = answerFontSize * 1.3;
              let y = answerY;
              const spaceWidth = ctx.measureText(" ").width;
              
              answerLines.forEach((line) => {
                let x = w * 0.06;
                line.words.forEach((word, idx) => {
                  ctx.font = `${word.weight} ${answerFontSize}px "Manrope", sans-serif`;
                  ctx.fillStyle = word.mode === "accent" ? "#1a73e8" : "#202124";
                  if (idx > 0 && !word.noSpaceBefore) {
                    x += spaceWidth;
                  }
                  ctx.fillText(word.text, x, y);
                  x += word.width;
                });
                y += lineHeight;
              });
            }
          }

          // Skip standard text rendering for chat and search layouts (they have custom text rendering)
          if (state.layout === layouts.chat || state.layout === layouts.search) {
            // Footer only
            const footerSize = Math.round(Math.min(w, h) * 0.022);
            ctx.font = `${footerSize}px "Manrope", sans-serif`;
            ctx.fillStyle = state.palette.muted;
            const footerY = h - Math.max(20, Math.round(h * 0.06));
            const slideText = `–°–ª–∞–π–¥ ${index + 1} / ${total}`;
            ctx.fillText(slideText, w * 0.06, footerY);
            return;
          }

          // Use the same text layout as other slides instead of centered
          let marginX = w * 0.12;
          let marginY = h * 0.18;
          let maxWidth = w - marginX * 2;
          const footerSafe = Math.max(32, Math.round(h * 0.08));
          let maxHeight = h - marginY * 2 - footerSafe;

          const needsTightText = false; // CTA doesn't have image layout constraints
          const bodyScale = needsTightText ? 0.043 : 0.05;
          const bodyMin = needsTightText ? 0.03 : 0.034;
          let fontSize = Math.round(Math.min(w, h) * bodyScale); // Use body font size, not title size
          const minFont = Math.round(Math.min(w, h) * bodyMin);
          let lines = [];

          while (fontSize >= minFont) {
            ctx.font = `600 ${fontSize}px "${state.fontFamily}", sans-serif`;
            const segments = parseStyledSegments(text);
            const words = segmentsToWords(segments);
            lines = buildLinesFromWords(ctx, words, maxWidth, fontSize, state.fontFamily, false); // not a title
            const lineHeight = fontSize * 1.25;
            if (lines.length * lineHeight <= maxHeight) break;
            fontSize -= 2;
          }

          ctx.fillStyle = state.palette.text;
          ctx.textBaseline = "top";
          ctx.font = `600 ${fontSize}px "${state.fontFamily}", sans-serif`;
          const lineHeight = fontSize * 1.25;
          const linePaddingX = Math.max(14, Math.round(fontSize * 0.35));
          const linePaddingY = Math.max(10, Math.round(fontSize * 0.22));
          const lineGap = Math.round(fontSize * 0.28);

          const spaceWidth = ctx.measureText(" ").width;
          let y = marginY + (maxHeight - lines.length * (lineHeight + lineGap)) / 2;
          
          lines.forEach((line) => {
            let x = marginX;
            line.words.forEach((word, idx) => {
              ctx.font = `${word.weight} ${fontSize}px "${state.fontFamily}", sans-serif`;
              ctx.fillStyle = word.mode === "accent" ? accent : state.palette.text;
              if (idx > 0 && !word.noSpaceBefore) {
                x += spaceWidth;
              }
              ctx.fillText(word.text, x, y);
              x += word.width;
            });
            y += lineHeight + lineGap;
          });

          // Footer - show only slide number for CTA slide
          const footerSize = Math.round(fontSize * 0.45);
          ctx.font = `${footerSize}px "Manrope", sans-serif`;
          ctx.fillStyle = state.palette.muted;
          const footerY = h - Math.max(20, Math.round(h * 0.06));
          const slideText = `–°–ª–∞–π–¥ ${index + 1} / ${total}`;
          ctx.fillText(slideText, marginX, footerY);

          return;
        }

        // Text layout
        let marginX = w * 0.12;
        let marginY = h * 0.18;
        let maxWidth = w - marginX * 2;
        const footerSafe = Math.max(32, Math.round(h * 0.08));
        let maxHeight = h - marginY * 2 - footerSafe;

        if (slideImage && slideImage.mode) {
          if (slideImage.mode === "top") {
            drawCoverImageInRect(ctx, slideImage.img, { x: 0, y: 0, w, h: h / 2 });
            marginY = h * 0.55;
            maxHeight = h - marginY - h * 0.08 - footerSafe * 0.6;
          } else if (slideImage.mode === "bottom") {
            drawCoverImageInRect(ctx, slideImage.img, { x: 0, y: h / 2, w, h: h / 2 });
            marginY = h * 0.12;
            maxHeight = h * 0.35 - footerSafe * 0.4;
          } else if (slideImage.mode === "left") {
            drawCoverImageInRect(ctx, slideImage.img, { x: 0, y: 0, w: w / 2, h });
            marginX = w * 0.58;
            maxWidth = w - marginX - w * 0.08;
            maxHeight = h - marginY * 2 - footerSafe;
          } else if (slideImage.mode === "right") {
            drawCoverImageInRect(ctx, slideImage.img, { x: w / 2, y: 0, w: w / 2, h });
            marginX = w * 0.12;
            maxWidth = w * 0.35;
            maxHeight = h - marginY * 2 - footerSafe;
          } else if (slideImage.mode === "full") {
            if (!isTitle) {
              marginX = w * 0.12;
              marginY = h * 0.12;
              maxWidth = w * 0.76;
              maxHeight = h * 0.62 - footerSafe * 0.5;
            }
          }
        }

        // Adjust margins for left-aligned title positions (only for title slide)
        if (isTitle && state.titlePosition && (state.titlePosition === "bottom-left" || state.titlePosition === "top-left")) {
          marginX = w * 0.08;
          maxWidth = w * 0.65;
        }

        // Image placement hint (draw after image so it's visible)
        if (slideImage) {
          const rect = getImageRect(slideImage.mode, w, h);
          const labelMap = {
            full: "–§–æ—Ç–æ: –≤–µ—Å—å",
            top: "–§–æ—Ç–æ: –≤–µ—Ä—Ö",
            bottom: "–§–æ—Ç–æ: –Ω–∏–∑",
            left: "–§–æ—Ç–æ: –ª–µ–≤–æ",
            right: "–§–æ—Ç–æ: –ø—Ä–∞–≤–æ",
          };
          // drawImageModeHint(ctx, rect, labelMap[slideImage.mode] || "–§–æ—Ç–æ", accent);
        }

        // Skip standard text rendering for chat and search layouts (they have custom text rendering)
        if (state.layout === layouts.chat || state.layout === layouts.search) {
          // Footer only
          const footerSize = Math.round(Math.min(w, h) * 0.022);
          ctx.font = `${footerSize}px "Manrope", sans-serif`;
          ctx.fillStyle = state.palette.muted;
          const footerY = h - Math.max(20, Math.round(h * 0.06));
          const slideText = `–°–ª–∞–π–¥ ${index + 1} / ${total}`;
          ctx.fillText(slideText, w * 0.06, footerY);

          const handle = ctaInput.value.trim();
          if (handle) {
            ctx.textAlign = "right";
            ctx.fillText(handle, w - w * 0.06, footerY);
            ctx.textAlign = "left";
          }
          return;
        }

        const needsTightText =
          slideImage &&
          (slideImage.mode === "left" || slideImage.mode === "right" || slideImage.mode === "top" || slideImage.mode === "bottom");
        const bodyScale = needsTightText ? 0.043 : 0.05;
        const bodyMin = needsTightText ? 0.03 : 0.034;
        let fontSize = Math.round(Math.min(w, h) * (isTitle ? 0.06 : bodyScale));
        const minFont = Math.round(Math.min(w, h) * (isTitle ? 0.038 : bodyMin));
        let lines = [];

        while (fontSize >= minFont) {
          ctx.font = `${isTitle ? 800 : 600} ${fontSize}px "${state.fontFamily}", sans-serif`;
          const segments = parseStyledSegments(text);
          const words = segmentsToWords(segments);
          lines = buildLinesFromWords(ctx, words, maxWidth, fontSize, state.fontFamily, isTitle);
          const lineHeight = fontSize * 1.25;
          if (lines.length * lineHeight <= maxHeight) break;
          fontSize -= 2;
        }

        ctx.fillStyle = state.palette.text;
        ctx.textBaseline = "top";
        ctx.font = `${isTitle ? 800 : 600} ${fontSize}px "${state.fontFamily}", sans-serif`;
        const lineHeight = fontSize * 1.25;
        const blockHeight = lines.length * lineHeight;
        
        // Calculate Y position based on title position setting (for title slide only)
        let y;
        if (isTitle && state.titlePosition) {
          if (state.titlePosition === "bottom-left") {
            // Position at bottom left with some padding from footer
            const footerSafe = Math.max(60, Math.round(h * 0.12));
            y = h - footerSafe - blockHeight;
          } else if (state.titlePosition === "top-left") {
            // Position at top left
            y = h * 0.12;
          } else {
            // Default center
            y = marginY + (maxHeight - blockHeight) / 2;
          }
        } else {
          // Default center for non-title slides
          y = marginY + (maxHeight - blockHeight) / 2;
        }

        const linePaddingX = Math.max(14, Math.round(fontSize * 0.35));
        const linePaddingY = Math.max(10, Math.round(fontSize * 0.22));
        const lineGap = Math.round(fontSize * 0.28);

        const spaceWidth = ctx.measureText(" ").width;
        
        // Determine if we need underlay and text color (only for title slide)
        const needsUnderlay = isTitle && state.textUnderlay !== "none";
        const underlay = underlays[state.underlay] || underlays.white;
        
        // Calculate text color based on underlay presence
        let textColor;
        if (needsUnderlay) {
          // If underlay is enabled, use underlay text color
          textColor = underlay.text;
        } else {
          // No underlay - use palette text color
          textColor = state.palette.text;
        }
        
        // Draw card underlay (one big rectangle for all text) - only for title slide
        if (needsUnderlay && state.textUnderlay === "card" && lines.length > 0) {
          // Find max line width
          let maxLineWidth = 0;
          lines.forEach(line => {
            if (line.width > maxLineWidth) maxLineWidth = line.width;
          });
          
          const cardPaddingX = linePaddingX * 1.5;
          const cardPaddingY = linePaddingY * 1.5;
          const cardW = maxLineWidth + cardPaddingX * 2;
          const cardH = (lines.length * lineHeight) + ((lines.length - 1) * lineGap) + cardPaddingY * 2;
          const cardX = marginX - cardPaddingX;
          const cardY = y - cardPaddingY;
          
          ctx.fillStyle = underlay.color;
          ctx.beginPath();
          ctx.roundRect(cardX, cardY, cardW, cardH, Math.max(16, Math.round(fontSize * 0.4)));
          ctx.fill();
        }
        
        lines.forEach((line) => {
          // Draw line underlay (individual rectangle for each line)
          if (needsUnderlay && state.textUnderlay === "line") {
            const lineWidth = line.width;
            const rectW = lineWidth + linePaddingX * 2;
            const rectH = lineHeight + linePaddingY * 2;
            const rectX = marginX - linePaddingX;
            const rectY = y - linePaddingY;
            ctx.fillStyle = underlay.color;
            ctx.beginPath();
            ctx.roundRect(rectX, rectY, rectW, rectH, Math.max(10, Math.round(fontSize * 0.3)));
            ctx.fill();
          }

          let x = marginX;
          // Check if this line has header
          const hasHeader = line.words.some(w => w.mode === "header");
          
          line.words.forEach((word, idx) => {
            // Header text is 1.3x larger
            const wordFontSize = word.mode === "header" ? Math.round(fontSize * 1.3) : fontSize;
            ctx.font = `${word.weight} ${wordFontSize}px "${state.fontFamily}", sans-serif`;
            
            // Header uses dark background color for contrast
            if (word.mode === "header") {
              ctx.fillStyle = state.palette.bgDark;
            } else if (word.mode === "accent") {
              ctx.fillStyle = accent;
            } else {
              ctx.fillStyle = textColor;
            }
            
            if (idx > 0 && !word.noSpaceBefore) {
              x += spaceWidth;
            }
            ctx.fillText(word.text, x, y);
            x += word.width;
          });
          y += lineHeight + lineGap;
          // Add extra spacing after header line (30% of line height)
          if (hasHeader) {
            y += lineHeight * 0.3;
          }
        });

        // Footer
        const footerSize = Math.round(fontSize * 0.45);
        ctx.font = `${footerSize}px "Manrope", sans-serif`;
        ctx.fillStyle = state.palette.muted;
        const footerY = h - Math.max(20, Math.round(h * 0.06));
        const slideText = `–°–ª–∞–π–¥ ${index + 1} / ${total}`;
        ctx.fillText(slideText, marginX, footerY);

        const handle = ctaInput.value.trim();
        if (handle) {
          ctx.textAlign = "right";
          ctx.fillText(handle, w - marginX, footerY);
          ctx.textAlign = "left";
        }
      }

      function normalizeAiResult(result) {
        const title = (result.title || "").toString().slice(0, 60).trim();
        const slidesRaw = Array.isArray(result.slides) ? result.slides : [];
        const slides = slidesRaw
          .map((s) => {
            const text = s.toString().trim();
            // Normalize multiple newlines to double newline (paragraph separator)
            // But preserve intentional line breaks for chat/search layouts
            return text.replace(/[\r\n]{3,}/g, '\n\n').replace(/\r/g, '\n');
          })
          .filter(Boolean)
          .map((s) => (s.length > 400 ? s.slice(0, 397) + "..." : s));
        return { title, slides };
      }

      function renderPreviews() {
        preview.innerHTML = "";
        const slideOptions = document.getElementById("slideOptions");
        if (!state.slides.length && !state.title) {
          empty.style.display = "block";
          downloadBtn.disabled = true;
          downloadBtn.style.display = "none";
          saveAllBtn.disabled = true;
          saveAllBtn.style.display = "none";
          if (slideOptions) slideOptions.style.display = "none";
          return;
        }
        empty.style.display = "none";
        downloadBtn.style.display = "inline-flex";
        saveAllBtn.style.display = "inline-flex";
        if (slideOptions) slideOptions.style.display = "flex";
        const allSlides =
          state.mode === "cover"
            ? [state.title || (state.slides[0] || "")].filter(Boolean)
            : [state.title, ...state.slides, state.cta].filter(Boolean);
        allSlides.forEach((text, index) => {
          const card = document.createElement("div");
          card.className = "preview-card";
          
          // Create container for canvas and download button
          const container = document.createElement("div");
          container.style.position = "relative";
          container.style.width = "100%";
          
          const canvas = document.createElement("canvas");
          const slideImage = state.slideImages[index];
          const isCta = state.cta && index === allSlides.length - 1 && state.mode !== "cover";
          drawSlide(canvas, text, index, allSlides.length, index === 0, slideImage, isCta);
          container.appendChild(canvas);
          
          // Add download button for mobile
          const saveBtn = document.createElement("button");
          saveBtn.innerHTML = "üì•";
          saveBtn.className = "save-btn";
          saveBtn.style.position = "absolute";
          saveBtn.style.top = "8px";
          saveBtn.style.right = "8px";
          saveBtn.style.background = "rgba(0, 0, 0, 0.6)";
          saveBtn.style.border = "none";
          saveBtn.style.borderRadius = "50%";
          saveBtn.style.width = "36px";
          saveBtn.style.height = "36px";
          saveBtn.style.color = "white";
          saveBtn.style.fontSize = "16px";
          saveBtn.style.cursor = "pointer";
          saveBtn.style.zIndex = "10";
          saveBtn.style.display = "none"; // Initially hidden, shown on mobile
          saveBtn.style.backdropFilter = "blur(4px)";
          saveBtn.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
          saveBtn.title = "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –≥–∞–ª–µ—Ä–µ—é";

          // Add save functionality with optimal method
          saveBtn.addEventListener("click", async (e) => {
            e.stopPropagation(); // Prevent opening image modal

            // Create temporary canvas to draw the slide
            const tempCanvas = document.createElement("canvas");
            const { w, h } = state.size;
            tempCanvas.width = w;
            tempCanvas.height = h;

            // Redraw the slide on the temporary canvas
            drawSlide(tempCanvas, text, index, allSlides.length, index === 0, slideImage, isCta);

            // Convert to blob
            const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/jpeg', 0.92));
            const filename = `slide-${index + 1}_${w}x${h}.jpg`;

            // Use the new save function
            await saveSlideToGallery(blob, filename, saveBtn);
          });

          container.appendChild(saveBtn);
          card.appendChild(container);

          // Show download button on all touch devices and mobile
          if (isMobileDevice() || window.matchMedia('(pointer: coarse)').matches) {
            saveBtn.style.display = "flex";
            saveBtn.style.alignItems = "center";
            saveBtn.style.justifyContent = "center";
          }
          
          card.addEventListener("click", () => openImageModal(index));
          preview.appendChild(card);
        });
        document.getElementById("downloadBtn").disabled = false;
        document.getElementById("saveAllBtn").disabled = false;
      }

      async function downloadZip() {
        if (!state.slides.length && !state.title) return;
        const zip = new JSZip();
        const { w, h } = state.size;
        const allSlides =
          state.mode === "cover"
            ? [state.title || (state.slides[0] || "")].filter(Boolean)
            : [state.title, ...state.slides, state.cta].filter(Boolean);

        for (let i = 0; i < allSlides.length; i++) {
          const canvas = document.createElement("canvas");
          const slideImage = state.slideImages[i];
          const isCta = state.cta && i === allSlides.length - 1 && state.mode !== "cover";
          drawSlide(canvas, allSlides[i], i, allSlides.length, i === 0, slideImage, isCta);
          const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
          const base64 = dataUrl.split(",")[1];
          zip.file(`slide-${i + 1}_${w}x${h}.jpg`, base64, { base64: true });
        }

        const blob = await zip.generateAsync({ type: "blob" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `carousel_${w}x${h}.zip`;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(link.href);
      }

      async function downloadImagesIndividually() {
        if (!state.slides.length && !state.title) return;
        const { w, h } = state.size;
        const allSlides =
          state.mode === "cover"
            ? [state.title || (state.slides[0] || "")].filter(Boolean)
            : [state.title, ...state.slides, state.cta].filter(Boolean);

        // For iOS: Use batch save modal for sequential saving
        if (isIOS()) {
          startBatchSave();
          return;
        }

        // For Android with Web Share API support: share all files at once
        if (canShareFiles() && isMobileDevice()) {
          const files = [];
          for (let i = 0; i < allSlides.length; i++) {
            const canvas = document.createElement("canvas");
            canvas.width = w;
            canvas.height = h;
            const slideImage = state.slideImages[i];
            const isCta = state.cta && i === allSlides.length - 1 && state.mode !== "cover";
            drawSlide(canvas, allSlides[i], i, allSlides.length, i === 0, slideImage, isCta);
            
            const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.92));
            const file = new File([blob], `slide-${i + 1}_${w}x${h}.jpg`, { type: 'image/jpeg' });
            files.push(file);
          }

          try {
            if (navigator.canShare && navigator.canShare({ files })) {
              await navigator.share({ files });
              showToast('‚úÖ –í—ã–±–µ—Ä–∏—Ç–µ ¬´–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—Å–µ¬ª –≤ –º–µ–Ω—é', 'success');
              return;
            }
          } catch (err) {
            console.log('Share API failed:', err);
            // Fallback to sequential download
          }
        }

        // Fallback: sequential download for other devices
        for (let i = 0; i < allSlides.length; i++) {
          const canvas = document.createElement("canvas");
          canvas.width = w;
          canvas.height = h;
          const slideImage = state.slideImages[i];
          const isCta = state.cta && i === allSlides.length - 1 && state.mode !== "cover";
          drawSlide(canvas, allSlides[i], i, allSlides.length, i === 0, slideImage, isCta);
          
          const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.92));
          await saveSlideToGallery(blob, `slide-${i + 1}_${w}x${h}.jpg`);
          
          if (i < allSlides.length - 1) {
            await new Promise((r) => setTimeout(r, 600));
          }
        }
      }

      // iOS Gallery Modal for saving multiple slides
      function showIosGalleryModal(allSlides, w, h) {
        // Create modal if doesn't exist
        let galleryModal = document.getElementById('iosGalleryModal');
        if (!galleryModal) {
          galleryModal = document.createElement('div');
          galleryModal.id = 'iosGalleryModal';
          galleryModal.className = 'modal';
          galleryModal.innerHTML = `
            <div class="modal-card ios-gallery-card">
              <div class="ios-gallery-header">
                <h3>–°–æ—Ö—Ä–∞–Ω–∏—Ç–µ —Å–ª–∞–π–¥—ã</h3>
                <button class="ghost ios-close-btn" onclick="closeIosGalleryModal()">‚úï</button>
              </div>
              <div class="ios-gallery-subtitle">–ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Å–ª–∞–π–¥, –∑–∞—Ç–µ–º —É–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è</div>
              <div class="ios-gallery-grid" id="iosGalleryGrid"></div>
            </div>
          `;
          document.body.appendChild(galleryModal);
          
          // Add styles
          const style = document.createElement('style');
          style.textContent = `
            .ios-gallery-card {
              width: min(480px, 95vw);
              max-height: 90vh;
              overflow-y: auto;
            }
            .ios-gallery-header {
              display: flex;
              align-items: center;
              justify-content: space-between;
              padding-bottom: 12px;
              border-bottom: 1px solid var(--stroke);
            }
            .ios-gallery-header h3 {
              margin: 0;
              font-size: 18px;
              color: var(--text);
            }
            .ios-gallery-subtitle {
              padding: 12px 0;
              color: var(--muted);
              font-size: 13px;
              text-align: center;
            }
            .ios-gallery-grid {
              display: grid;
              grid-template-columns: repeat(2, 1fr);
              gap: 12px;
              padding: 8px 0;
            }
            .ios-gallery-item {
              position: relative;
              border-radius: 12px;
              overflow: hidden;
              border: 2px solid transparent;
              transition: all 0.2s;
              background: rgba(255,255,255,0.05);
              aspect-ratio: ${w}/${h};
            }
            .ios-gallery-item:active {
              transform: scale(0.98);
            }
            .ios-gallery-item img {
              width: 100%;
              height: 100%;
              object-fit: cover;
              display: block;
            }
            .ios-gallery-item-number {
              position: absolute;
              top: 8px;
              left: 8px;
              background: rgba(0,0,0,0.6);
              color: white;
              padding: 4px 8px;
              border-radius: 6px;
              font-size: 12px;
              font-weight: 600;
              z-index: 2;
            }
            .ios-gallery-item img {
              -webkit-touch-callout: default !important;
              -webkit-user-select: auto !important;
              user-select: auto !important;
              pointer-events: auto !important;
              touch-action: auto !important;
            }
          `;
          document.head.appendChild(style);
        }

        // Generate grid
        const grid = document.getElementById('iosGalleryGrid');
        grid.innerHTML = '';
        
        allSlides.forEach(async (text, index) => {
          const canvas = document.createElement('canvas');
          canvas.width = w;
          canvas.height = h;
          const slideImage = state.slideImages[index];
          const isCta = state.cta && index === allSlides.length - 1 && state.mode !== "cover";
          drawSlide(canvas, text, index, allSlides.length, index === 0, slideImage, isCta);
          
          // Convert to blob URL for iOS long-press support
          const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.92));
          const blobUrl = URL.createObjectURL(blob);
          
          const item = document.createElement('div');
          item.className = 'ios-gallery-item';
          item.dataset.blobUrl = blobUrl; // Store for cleanup
          
          const img = document.createElement('img');
          img.src = blobUrl;
          img.alt = `Slide ${index + 1}`;
          img.style.webkitTouchCallout = 'default'; // Enable iOS long-press menu
          img.style.webkitUserSelect = 'none';
          img.draggable = false;
          
          const number = document.createElement('span');
          number.className = 'ios-gallery-item-number';
          number.textContent = index + 1;
          
          item.appendChild(number);
          item.appendChild(img);
          
          // Open full-size modal on click
          item.addEventListener('click', (e) => {
            e.preventDefault();
            const iosModal = document.getElementById('iosSaveModal');
            const iosImage = document.getElementById('iosSaveImage');
            iosImage.src = blobUrl;
            iosModal.classList.add('open');
            iosModal.setAttribute('aria-hidden', 'false');
          });
          
          // Enable long-press context menu on the item itself
          item.addEventListener('touchstart', function(e) {
            // Allow default behavior for long-press
          }, { passive: true });
          
          grid.appendChild(item);
        });

        // Show modal
        galleryModal.classList.add('open');
        galleryModal.setAttribute('aria-hidden', 'false');
        
        // Close handler
        galleryModal.addEventListener('click', (e) => {
          if (e.target === galleryModal) closeIosGalleryModal();
        });
      }

      function closeIosGalleryModal() {
        const galleryModal = document.getElementById('iosGalleryModal');
        if (galleryModal) {
          galleryModal.classList.remove('open');
          galleryModal.setAttribute('aria-hidden', 'true');
        }
        // Cleanup blob URLs after modal closes
        setTimeout(cleanupGalleryBlobs, 100);
      }

      // Batch save for iOS - sequential saving of all slides
      let batchSaveData = {
        images: [],
        currentIndex: 0
      };

      async function startBatchSave() {
        if (!state.slides.length && !state.title) return;
        const { w, h } = state.size;
        const allSlides =
          state.mode === "cover"
            ? [state.title || (state.slides[0] || "")].filter(Boolean)
            : [state.title, ...state.slides, state.cta].filter(Boolean);

        // Generate all blobs
        const images = [];
        for (let i = 0; i < allSlides.length; i++) {
          const canvas = document.createElement("canvas");
          canvas.width = w;
          canvas.height = h;
          const slideImage = state.slideImages[i];
          const isCta = state.cta && i === allSlides.length - 1 && state.mode !== "cover";
          drawSlide(canvas, allSlides[i], i, allSlides.length, i === 0, slideImage, isCta);
          
          const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.92));
          const blobUrl = URL.createObjectURL(blob);
          images.push({
            blob: blob,
            blobUrl: blobUrl,
            filename: `slide-${i + 1}_${w}x${h}.jpg`
          });
        }

        batchSaveData = {
          images: images,
          currentIndex: 0
        };

        showBatchSaveModal();
      }

      function showBatchSaveModal() {
        const modal = document.getElementById('iosBatchSaveModal');
        const image = document.getElementById('iosBatchSaveImage');
        const currentEl = document.getElementById('batchCurrent');
        const totalEl = document.getElementById('batchTotal');
        const nextBtn = document.getElementById('iosBatchNextBtn');
        const doneBtn = document.getElementById('iosBatchDoneBtn');

        if (batchSaveData.currentIndex >= batchSaveData.images.length) {
          // All done
          closeBatchSaveModal();
          showToast('‚úÖ –í—Å–µ —Ñ–æ—Ç–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!', 'success');
          return;
        }

        const current = batchSaveData.images[batchSaveData.currentIndex];
        image.src = current.blobUrl;
        currentEl.textContent = batchSaveData.currentIndex + 1;
        totalEl.textContent = batchSaveData.images.length;

        // Show/hide buttons based on progress
        if (batchSaveData.currentIndex === batchSaveData.images.length - 1) {
          nextBtn.classList.add('hidden');
          doneBtn.classList.remove('hidden');
        } else {
          nextBtn.classList.remove('hidden');
          doneBtn.classList.add('hidden');
        }

        modal.classList.add('open');
        modal.setAttribute('aria-hidden', 'false');
      }

      function nextBatchImage() {
        batchSaveData.currentIndex++;
        showBatchSaveModal();
      }

      function closeBatchSaveModal() {
        const modal = document.getElementById('iosBatchSaveModal');
        modal.classList.remove('open');
        modal.setAttribute('aria-hidden', 'true');
        
        // Cleanup all blob URLs
        batchSaveData.images.forEach(img => {
          if (img.blobUrl) URL.revokeObjectURL(img.blobUrl);
        });
        batchSaveData = { images: [], currentIndex: 0 };
      }

      // Batch save event listeners
      document.getElementById('iosBatchNextBtn').addEventListener('click', nextBatchImage);
      document.getElementById('iosBatchDoneBtn').addEventListener('click', closeBatchSaveModal);
      document.getElementById('closeIosBatchModalBtn').addEventListener('click', closeBatchSaveModal);
      document.getElementById('iosBatchSaveModal').addEventListener('click', (e) => {
        if (e.target.id === 'iosBatchSaveModal') closeBatchSaveModal();
      });

      function buildPrompt() {
        return `–¢—ã ‚Äî –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä –∫–∞—Ä—É—Å–µ–ª–µ–π –¥–ª—è Instagram, —Å–æ–∑–¥–∞—é—â–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ.

–ó–ê–î–ê–ß–ê:
–°–æ–∑–¥–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∫–∞—Ä—É—Å–µ–ª–∏ –≤ —Å—Ç—Ä–æ–≥–æ–º —Ñ–æ—Ä–º–∞—Ç–µ JSON –ø–æ –∑–∞–¥–∞–Ω–Ω–æ–π —Ç–µ–º–µ.

–§–û–†–ú–ê–¢ –û–¢–í–ï–¢–ê (—Ç–æ–ª—å–∫–æ JSON, –±–µ–∑ markdown, –±–µ–∑ –ø–æ—è—Å–Ω–µ–Ω–∏–π):
{
  "title": "—Å—Ç—Ä–æ–∫–∞ –¥–æ 60 —Å–∏–º–≤–æ–ª–æ–≤",
  "slides": ["—Å—Ç—Ä–æ–∫–∞ 1", "—Å—Ç—Ä–æ–∫–∞ 2", "..."]
}

–¢–†–ï–ë–û–í–ê–ù–ò–Ø –ö –°–û–î–ï–†–ñ–ê–ù–ò–Æ:
- title: –ø—Ä–∏–≤–ª–µ–∫–∞—é—â–∏–π –≤–Ω–∏–º–∞–Ω–∏–µ, –æ—Ç—Ä–∞–∂–∞—é—â–∏–π —Å—É—Ç—å —Ç–µ–º—ã, –∏–Ω—Ç—Ä–∏–≥—É—é—â–∏–π
- slides: 3-8 —Å–ª–∞–π–¥–æ–≤, –∫–∞–∂–¥—ã–π –¥–æ 200 —Å–∏–º–≤–æ–ª–æ–≤
- –ö–∞–∂–¥—ã–π —Å–ª–∞–π–¥ ‚Äî —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–∞—è –º—ã—Å–ª—å, –±–µ–∑ –≤–æ–¥—ã –∏ –ø–æ–≤—Ç–æ—Ä–æ–≤
- –°—Ç–∏–ª—å: —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –º–∏–Ω–∏–º–∞–ª–∏–∑–º, –ª–∞–∫–æ–Ω–∏—á–Ω–æ—Å—Ç—å, –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π
- –ë–µ–∑ —Å–ø–∏—Å–∫–æ–≤, –Ω—É–º–µ—Ä–∞—Ü–∏–∏, —ç–º–æ–¥–∑–∏ –≤–Ω—É—Ç—Ä–∏ —Å–ª–∞–π–¥–æ–≤
- –õ–æ–≥–∏—á–µ—Å–∫–∞—è —Å–≤—è–∑—å –º–µ–∂–¥—É —Å–ª–∞–π–¥–∞–º–∏: –æ—Ç –ø—Ä–æ–±–ª–µ–º—ã –∫ —Ä–µ—à–µ–Ω–∏—é
- –ü–µ—Ä–≤—ã–π —Å–ª–∞–π–¥ (–ø–æ—Å–ª–µ –∑–∞–≥–æ–ª–æ–≤–∫–∞) ‚Äî hook, –ø–æ—Å–ª–µ–¥–Ω–∏–π ‚Äî –≤—ã–≤–æ–¥/–ø—Ä–∏–∑—ã–≤ –∫ –¥–µ–π—Å—Ç–≤–∏—é

–§–û–†–ú–ê–¢–ò–†–û–í–ê–ù–ò–ï –¢–ï–ö–°–¢–ê (–∏—Å–ø–æ–ª—å–∑—É–π —É–º–µ—Ä–µ–Ω–Ω–æ, —Ç–æ–ª—å–∫–æ –≥–¥–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ):
- <accent>—Ç–µ–∫—Å—Ç</accent> ‚Üí –≤—ã–¥–µ–ª–∏—Ç—å –í–ê–ñ–ù–´–ï —Å–ª–æ–≤–∞/—Ñ—Ä–∞–∑—ã –∞–∫—Ü–µ–Ω—Ç–Ω—ã–º —Ü–≤–µ—Ç–æ–º (1-2 –Ω–∞ —Å–ª–∞–π–¥)
- <bold>—Ç–µ–∫—Å—Ç</bold> ‚Üí –≤—ã–¥–µ–ª–∏—Ç—å –∂–∏—Ä–Ω—ã–º –¥–ª—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∞–∫—Ü–µ–Ω—Ç–∞
- <header>—Ç–µ–∫—Å—Ç</header> ‚Üí –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å–ª–∞–π–¥–∞, —Ç–æ–ª—å–∫–æ –¥–ª—è –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏—è —Ç–µ–º—ã —Å–ª–∞–π–¥–∞

–ö–û–ì–î–ê –ò–°–ü–û–õ–¨–ó–û–í–ê–¢–¨ –¢–ï–ì–ò:
‚úì <header> ‚Äî —Ç–æ–ª—å–∫–æ –¥–ª—è –Ω–∞–∑–≤–∞–Ω–∏—è —Ä–∞–∑–¥–µ–ª–∞ –∏–ª–∏ –≥–ª–∞–≤–Ω–æ–π –º—ã—Å–ª–∏ —Å–ª–∞–π–¥–∞
‚úì <accent> ‚Äî –∫–ª—é—á–µ–≤—ã–µ –≤—ã–≥–æ–¥—ã, —Ü–∏—Ñ—Ä—ã, —Å—Ä–æ–∫–∏, —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
‚úó –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π —Ç–µ–≥–∏ –¥–ª—è –≤—Å–µ–≥–æ —Ç–µ–∫—Å—Ç–∞ ‚Äî —Ç–æ–ª—å–∫–æ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è
‚úó –ù–µ –≤–∫–ª–∞–¥—ã–≤–∞–π —Ç–µ–≥–∏ –¥—Ä—É–≥ –≤ –¥—Ä—É–≥–∞

–ü–†–ò–ú–ï–†–´ –•–û–†–û–®–ò–• –°–õ–ê–ô–î–û–í:
- "<header>–û—à–∏–±–∫–∞ ‚Ññ1</header> –î–µ–ª–∞—Ç—å –≤—Å—ë —Å–∞–º–æ–º—É –≤–º–µ—Å—Ç–æ –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–∏—è"
- "<accent>–≠–∫–æ–Ω–æ–º–∏—è 10 —á–∞—Å–æ–≤</accent> –≤ –Ω–µ–¥–µ–ª—é –±–ª–∞–≥–æ–¥–∞—Ä—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏"
- "–†–µ–∑—É–ª—å—Ç–∞—Ç –≤–∏–¥–µ–Ω —É–∂–µ <accent>—á–µ—Ä–µ–∑ 7 –¥–Ω–µ–π</accent> —Ä–µ–≥—É–ª—è—Ä–Ω–æ–π –ø—Ä–∞–∫—Ç–∏–∫–∏"

–ü–†–ò–ú–ï–†–´ –ü–õ–û–•–ò–• –°–õ–ê–ô–î–û–í:
- "–í–æ—Ç 5 —Å–ø–æ—Å–æ–±–æ–≤... 1. –ü–µ—Ä–≤—ã–π —Å–ø–æ—Å–æ–±... 2. –í—Ç–æ—Ä–æ–π —Å–ø–æ—Å–æ–±..." (—Å–ø–∏—Å–∫–∏)
- "üî• –ö—Ä—É—Ç–æ–π –ª–∞–π—Ñ—Ö–∞–∫!!! üöÄ" (—ç–º–æ–¥–∑–∏)
- "–≠—Ç–æ –æ—á–µ–Ω—å –≤–∞–∂–Ω–æ!!!" (–∫–∞–ø—Å –∏ –º–Ω–æ–≥–æ—Ç–æ—á–∏—è)

–û–¢–í–ï–¢ –î–û–õ–ñ–ï–ù –ë–´–¢–¨:
- –í–∞–ª–∏–¥–Ω—ã–º JSON (–ø—Ä–æ–≤–µ—Ä—å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å!)
- –ë–µ–∑ markdown-—Ä–∞–∑–º–µ—Ç–∫–∏ (\`\`\`json –∏ —Ç.–¥.)
- –ë–µ–∑ –ø–æ—è—Å–Ω–µ–Ω–∏–π –ø–µ—Ä–µ–¥ –∏–ª–∏ –ø–æ—Å–ª–µ JSON
- –¢–æ–ª—å–∫–æ –ø–æ–ª–µ "title" –∏ –º–∞—Å—Å–∏–≤ "slides"

–¢–µ–º–∞:`;
      }

      function applyStateFromInputs() {
        state.mode = modeSelect.value || "carousel";
        state.size = parseSize(sizeSelect.value);
        state.fontFamily = fontSelect.value || "Manrope";
        const activeLayout = layoutPicker.querySelector(".chip.active")?.getAttribute("data-layout") || "line";
        const activePalette = colorPicker.querySelector(".chip.active")?.getAttribute("data-palette") || "midnight";
        const activeUnderlay = underlayPicker.querySelector(".chip.active")?.getAttribute("data-underlay") || "white";
        state.palette = palettes[activePalette] || palettes.midnight;
        state.layout = layouts[activeLayout] || layouts.line;
        state.underlay = activeUnderlay;
        const ctaTarget = ctaInput.value.trim();
        const ctaText = ctaTextInput.value.trim();
        state.cta = ctaTarget ? `${ctaText ? ctaText + " " : ""}${ctaTarget}`.trim() : "";
      }

      function openImageModal(index) {
        state.pendingImageIndex = index;
        imageModal.classList.add("open");
        imageModal.setAttribute("aria-hidden", "false");
      }

      function closeImageModal() {
        imageModal.classList.remove("open");
        imageModal.setAttribute("aria-hidden", "true");
        state.pendingImageIndex = null;
        state.pendingImageMode = null;
      }

      fromJsonBtn.addEventListener("click", () => {
        const raw = sanitizeJsonInput(jsonInput.value);
        if (!raw) {
          alert("–í—Å—Ç–∞–≤—å—Ç–µ JSON –∏–ª–∏ —Ç–µ–∫—Å—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–∞—Ä—É—Å–µ–ª–∏.");
          return;
        }
        
        // Try to parse as JSON first
        let parsed = null;
        let jsonError = null;
        
        try {
          // Try direct parsing
          parsed = JSON.parse(raw);
        } catch (err) {
          jsonError = err;
          
          // Try to extract JSON from text
          const jsonMatch = raw.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            try {
              parsed = JSON.parse(jsonMatch[0]);
              jsonError = null;
            } catch (extractErr) {
              jsonError = extractErr;
            }
          }
        }
        
        // If JSON parsing failed, try to convert text to carousel structure
        if (!parsed && jsonError) {
          // Check if it's plain text (not JSON)
          if (!raw.trim().startsWith('{')) {
            // Convert text to carousel structure
            const lines = raw.split(/\n\n+|\n/).filter(line => line.trim());
            if (lines.length > 0) {
              // First line is title, rest are slides
              parsed = {
                title: lines[0].trim(),
                slides: lines.slice(1).map(line => line.trim()).filter(line => line)
              };
              
              // If only one line, split by sentences
              if (parsed.slides.length === 0) {
                const sentences = lines[0].match(/[^.!?]+[.!?]+/g) || [lines[0]];
                if (sentences.length > 1) {
                  parsed.title = sentences[0].trim();
                  parsed.slides = sentences.slice(1).map(s => s.trim()).filter(s => s);
                } else {
                  // Single text - make it the only slide
                  parsed.slides = [lines[0].trim()];
                }
              }
              
              console.log("Auto-converted text to carousel:", parsed);
            }
          }
        }
        
        // If still no valid data, show error
        if (!parsed) {
          console.error("JSON Parse Error:", jsonError);
          console.error("Input text:", raw.substring(0, 200));
          
          let errorMsg = "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π JSON.";
          if (jsonError && jsonError.message) {
            const match = jsonError.message.match(/position (\d+)/);
            if (match) {
              const pos = parseInt(match[1]);
              const context = raw.substring(Math.max(0, pos - 30), Math.min(raw.length, pos + 30));
              errorMsg += `\n\n–û—à–∏–±–∫–∞ –æ–∫–æ–ª–æ:\n...${context}...\n${' '.repeat(33)}^`;
            } else {
              errorMsg += `\n\n${jsonError.message}`;
            }
          }
          errorMsg += "\n\n–ü–æ–¥—Å–∫–∞–∑–∫–∞: –≤—Å—Ç–∞–≤—å—Ç–µ JSON —Å –ø–æ–ª—è–º–∏ 'title' –∏ 'slides', –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ —Ç–µ–∫—Å—Ç –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏.";
          alert(errorMsg);
          return;
        }
        
        // Validate structure
        if (typeof parsed !== 'object' || parsed === null) {
          alert("–î–∞–Ω–Ω—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ–±—ä–µ–∫—Ç–æ–º —Å –ø–æ–ª—è–º–∏ 'title' –∏ 'slides'.");
          return;
        }
        
        if (!('title' in parsed) || !('slides' in parsed)) {
          alert("–ù–µ–æ–±—Ö–æ–¥–∏–º—ã –ø–æ–ª—è 'title' –∏ 'slides'.\n\n–ü—Ä–∏–º–µ—Ä JSON:\n{\n  \"title\": \"...\",\n  \"slides\": [\"...\", \"...\"]\n}\n\n–ò–ª–∏ –ø—Ä–æ—Å—Ç–æ –≤—Å—Ç–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç ‚Äî –æ–Ω –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞–∑–±–∏—Ç –Ω–∞ —Å–ª–∞–π–¥—ã.");
          return;
        }
        
        const normalized = normalizeAiResult(parsed);
        if (!normalized.title && !normalized.slides.length) {
          alert("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ –ø–æ–ª—è 'title' –∏ 'slides' –Ω–µ –ø—É—Å—Ç—ã–µ.");
          return;
        }
        
        applyStateFromInputs();
        state.title = normalized.title;
        state.slides = normalized.slides;
        state.slideImages = {};
        renderPreviews();
        
        // –ü–ª–∞–≤–Ω–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞ –∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º
        setTimeout(() => {
          const resultsSection = document.getElementById("resultsSection");
          if (resultsSection) {
            resultsSection.scrollIntoView({ behavior: "smooth", block: "start" });
          }
        }, 100);
      });

      function sanitizeJsonInput(input) {
        if (!input) return "";
        let text = input.replace(/^\uFEFF/, "").trim();
        
        // remove ```json ... ``` wrappers (multiline)
        text = text.replace(/^```(?:json)?\s*/i, "").replace(/\s*```$/i, "").trim();
        
        // remove single backticks if wrapped
        if (text.startsWith('`') && text.endsWith('`')) {
          text = text.slice(1, -1).trim();
        }
        
        // replace smart quotes with regular quotes
        text = text
          .replace(/[""‚Äû‚Äü]/g, '"')
          .replace(/['']/g, "'");
        
        // remove trailing commas before } or ]
        text = text.replace(/,(\s*[}\]])/g, '$1');
        
        // normalize line endings
        text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        
        return text;
      }

      function setActivePicker(container, attr, value) {
        const buttons = Array.from(container.querySelectorAll(".chip"));
        buttons.forEach((btn) => {
          const isActive = btn.getAttribute(`data-${attr}`) === value;
          btn.classList.toggle("active", isActive);
        });
      }

      layoutPicker.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-layout]");
        if (!btn) return;
        const value = btn.getAttribute("data-layout");
        setActivePicker(layoutPicker, "layout", value);
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      colorPicker.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-palette]");
        if (!btn) return;
        const value = btn.getAttribute("data-palette");
        setActivePicker(colorPicker, "palette", value);
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      underlayPicker.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-underlay]");
        if (!btn) return;
        const value = btn.getAttribute("data-underlay");
        setActivePicker(underlayPicker, "underlay", value);
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      sizeSelect.addEventListener("change", () => {
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      modeSelect.addEventListener("change", () => {
        if (state.mode === "cover") {
          sizeSelect.value = "1350x1080";
        }
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      fontSelect.addEventListener("change", () => {
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      const titlePositionSelect = document.getElementById("titlePositionSelect");
      titlePositionSelect.addEventListener("change", () => {
        state.titlePosition = titlePositionSelect.value;
        if (state.title || state.slides.length) {
          renderPreviews();
        }
      });

      const textUnderlaySelect = document.getElementById("textUnderlaySelect");
      textUnderlaySelect.addEventListener("change", () => {
        state.textUnderlay = textUnderlaySelect.value;
        if (state.title || state.slides.length) {
          renderPreviews();
        }
      });

      imageModal.addEventListener("click", (event) => {
        if (event.target === imageModal) closeImageModal();
      });

      closeModalBtn.addEventListener("click", closeImageModal);

      // iOS Save Modal close handler
      const iosSaveModal = document.getElementById('iosSaveModal');
      const closeIosModalBtn = document.getElementById('closeIosModalBtn');

      function closeIosModal() {
        iosSaveModal.classList.remove('open');
        iosSaveModal.setAttribute('aria-hidden', 'true');
        const iosImage = document.getElementById('iosSaveImage');
        if (iosImage.src && iosImage.src.startsWith('blob:')) {
          URL.revokeObjectURL(iosImage.src);
          iosImage.src = '';
        }
      }

      // Cleanup blob URLs from gallery when closing
      function cleanupGalleryBlobs() {
        const galleryItems = document.querySelectorAll('.ios-gallery-item');
        galleryItems.forEach(item => {
          const blobUrl = item.dataset.blobUrl;
          if (blobUrl) {
            URL.revokeObjectURL(blobUrl);
          }
        });
      }

      closeIosModalBtn.addEventListener('click', closeIosModal);
      iosSaveModal.addEventListener('click', (e) => {
        if (e.target === iosSaveModal) closeIosModal();
      });

      imageModal.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-mode]");
        if (!btn) return;
        const mode = btn.getAttribute("data-mode");
        if (mode === "remove") {
          if (state.pendingImageIndex !== null) {
            delete state.slideImages[state.pendingImageIndex];
            renderPreviews();
          }
          closeImageModal();
          return;
        }
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω–¥–µ–∫—Å –∏ —Ä–µ–∂–∏–º –≤ –ª–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø—Ä–æ–±–ª–µ–º —Å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç—å—é
        const currentIndex = state.pendingImageIndex;
        const currentMode = mode;
        
        if (currentIndex === null) {
          console.error("–ù–µ –≤—ã–±—Ä–∞–Ω –∏–Ω–¥–µ–∫—Å —Å–ª–∞–π–¥–∞");
          return;
        }
        
        slideImageInput.value = "";
        
        // –°–æ–∑–¥–∞–µ–º –æ–¥–Ω–æ—Ä–∞–∑–æ–≤—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è —ç—Ç–æ–≥–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞ —Ñ–∞–π–ª–∞
        const handleFileSelect = async () => {
          let file = slideImageInput.files?.[0];
          if (!file) {
            console.log("–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω");
            slideImageInput.removeEventListener("change", handleFileSelect);
            return;
          }
          
          console.log("–í—ã–±—Ä–∞–Ω —Ñ–∞–π–ª:", file.name, "–¥–ª—è —Å–ª–∞–π–¥–∞", currentIndex, "—Ä–µ–∂–∏–º:", currentMode);
          
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞
          const fileExtension = file.name.split('.').pop()?.toLowerCase();
          const isHeic = fileExtension === 'heic' || fileExtension === 'heif' || file.type === 'image/heic' || file.type === 'image/heif';
          
          // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º HEIC –≤ JPEG –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
          if (isHeic) {
            console.log("–û–±–Ω–∞—Ä—É–∂–µ–Ω HEIC —Ñ–∞–π–ª, –Ω–∞—á–∏–Ω–∞–µ–º –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é...");
            try {
              // –ò—Å–ø–æ–ª—å–∑—É–µ–º heic-to –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
              if (typeof HeicTo === 'undefined') {
                throw new Error("–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ heic-to –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞");
              }
              
              // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º HEIC –≤ JPEG Blob
              const jpegBlob = await HeicTo({
                blob: file,
                type: "image/jpeg",
                quality: 0.92
              });
              
              // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π File –æ–±—ä–µ–∫—Ç –∏–∑ Blob
              file = new File([jpegBlob], file.name.replace(/\.heic$/i, '.jpg'), { type: "image/jpeg" });
              console.log("HEIC —É—Å–ø–µ—à–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –≤ JPEG");
            } catch (err) {
              console.error("–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ HEIC:", err);
              alert("–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ HEIC: " + err.message + "\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–æ—Ç–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ JPEG –ø–µ—Ä–µ–¥ –∑–∞–≥—Ä—É–∑–∫–æ–π.");
              slideImageInput.removeEventListener("change", handleFileSelect);
              return;
            }
          }
          
          const reader = new FileReader();
          reader.onerror = () => {
            console.error("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞");
            alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞");
            slideImageInput.removeEventListener("change", handleFileSelect);
          };
          
          reader.onload = () => {
            const img = new Image();
            img.onerror = () => {
              console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è");
              alert("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–∞–π–ª —è–≤–ª—è–µ—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º (JPEG, PNG, GIF, WebP).");
              slideImageInput.removeEventListener("change", handleFileSelect);
            };
            
            img.onload = () => {
              console.log("–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ:", img.width, "x", img.height);
              state.slideImages[currentIndex] = {
                img,
                mode: currentMode,
              };
              console.log("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ state.slideImages[", currentIndex, "]");
              renderPreviews();
              closeImageModal();
              slideImageInput.removeEventListener("change", handleFileSelect);
            };
            img.src = reader.result;
          };
          reader.readAsDataURL(file);
        };
        
        slideImageInput.addEventListener("change", handleFileSelect);
        slideImageInput.click();
      });

      copyPromptBtn.addEventListener("click", async () => {
        const prompt = buildPrompt();
        await navigator.clipboard.writeText(prompt);
        copyPromptBtn.textContent = "‚úÖ –ü—Ä–æ–º–ø—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω! –í—Å—Ç–∞–≤—å –µ–≥–æ –≤ –ò–ò";
        setTimeout(() => (copyPromptBtn.textContent = "üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–º–ø—Ç"), 2500);
      });

      downloadBtn.addEventListener("click", () => {
        downloadZip();
      });

      saveAllBtn.addEventListener("click", () => {
        downloadImagesIndividually();
      });

      // Apply CTA changes without regenerating the carousel
      document.getElementById("applyCtaBtn").addEventListener("click", () => {
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
          
          // Visual feedback for button click
          const btn = document.getElementById("applyCtaBtn");
          btn.textContent = "‚úì –ü—Ä–∏–º–µ–Ω–µ–Ω–æ";
          btn.classList.add("primary");
          btn.classList.remove("secondary");
          
          setTimeout(() => {
            btn.textContent = "–ü—Ä–∏–º–µ–Ω–∏—Ç—å";
            btn.classList.add("secondary");
            btn.classList.remove("primary");
          }, 2000);
        }
      });

      // Also update CTA when input values change
      ctaInput.addEventListener("input", () => {
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      ctaTextInput.addEventListener("input", () => {
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });
    </script>
  </body>
</html>
// Deployed: –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫,  9 —Ñ–µ–≤—Ä–∞–ª—è 2026 –≥. 22:07:57 (MSK)
