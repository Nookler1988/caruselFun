<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>IG Carousel Maker</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Golos+Text:wght@400;600;700&family=Inter:wght@400;600;700&family=Manrope:wght@400;600;800&family=Montserrat:wght@400;600;700&family=Rubik:wght@400;600;700&display=swap");

      :root {
        --bg-1: #0b0f19;
        --bg-2: #151b2f;
        --accent-1: #00d4ff;
        --accent-2: #f4b86a;
        --text: #f5f7ff;
        --muted: #9aa3b2;
        --card: rgba(255, 255, 255, 0.06);
        --stroke: rgba(255, 255, 255, 0.12);
        --light: #f7f6f2;
        --dark: #0f1220;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Manrope", system-ui, -apple-system, sans-serif;
        color: var(--text);
        background: radial-gradient(1200px 800px at 15% 10%, #1d2450 0%, transparent 55%),
          radial-gradient(900px 700px at 80% 20%, #2a0f2f 0%, transparent 60%),
          linear-gradient(180deg, var(--bg-1), var(--bg-2));
        min-height: 100vh;
      }

      .page {
        max-width: 1100px;
        margin: 0 auto;
        padding: 40px 24px 80px;
        display: grid;
        gap: 24px;
      }

      header {
        display: grid;
        gap: 10px;
      }

      header h1 {
        font-family: "Space Grotesk", system-ui, sans-serif;
        font-size: clamp(28px, 4vw, 44px);
        margin: 0;
        letter-spacing: 0.3px;
      }

      header p {
        margin: 0;
        color: var(--muted);
      }

      .panel {
        display: grid;
        gap: 16px;
        padding: 18px;
        border-radius: 18px;
        background: var(--card);
        border: 1px solid var(--stroke);
        backdrop-filter: blur(14px);
      }

      .panel-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .step-panel {
        display: grid;
        gap: 12px;
        padding: 24px;
        border-radius: 18px;
        background: var(--card);
        border: 1px solid var(--stroke);
        backdrop-filter: blur(14px);
      }

      .step-header {
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .step-number {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--accent-1), #8bf0ff);
        color: var(--dark);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: 20px;
        flex-shrink: 0;
      }

      .step-title {
        font-size: 18px;
        font-weight: 600;
        color: var(--text);
      }

      .step-description {
        margin: 0;
        color: var(--muted);
        font-size: 14px;
        line-height: 1.5;
        padding-left: 56px;
      }

      .controls {
        display: grid;
        gap: 16px;
      }

      textarea {
        width: 100%;
        min-height: 180px;
        resize: vertical;
        border-radius: 14px;
        border: 1px solid var(--stroke);
        background: rgba(10, 13, 24, 0.7);
        color: var(--text);
        padding: 14px 16px;
        font-size: 16px;
        line-height: 1.5;
        outline: none;
      }

      input[type="text"] {
        width: 100%;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: rgba(10, 13, 24, 0.7);
        color: var(--text);
        padding: 10px 12px;
        font-size: 14px;
        outline: none;
      }

      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }

      select,
      button {
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: rgba(14, 18, 32, 0.85);
        color: var(--text);
        padding: 10px 14px;
        font-size: 15px;
        cursor: pointer;
      }

      button.primary {
        background: linear-gradient(135deg, var(--accent-1), #8bf0ff);
        color: #0b0f19;
        font-weight: 700;
        border: none;
      }

      button.secondary {
        border: 1px solid rgba(0, 212, 255, 0.4);
        color: var(--accent-1);
      }

      button.ghost {
        border: 1px solid var(--stroke);
        color: var(--muted);
        background: rgba(14, 18, 32, 0.5);
      }

      button.zip {
        border: 1px dashed rgba(0, 212, 255, 0.35);
        color: #cfeaff;
        background: rgba(8, 12, 24, 0.65);
        font-weight: 600;
      }

      .meta {
        font-size: 13px;
        color: var(--muted);
      }

      .picker {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(72px, 1fr));
        gap: 8px;
      }

      .chip {
        display: grid;
        gap: 4px;
        padding: 8px;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: rgba(14, 18, 32, 0.85);
        color: var(--text);
        cursor: pointer;
        text-align: left;
      }

      .chip.active {
        border-color: rgba(0, 212, 255, 0.5);
        box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2);
      }

      .layout-thumb,
      .color-thumb {
        height: 32px;
        border-radius: 10px;
        border: 1px solid var(--stroke);
        background: #f6f3ee;
        position: relative;
        overflow: hidden;
      }

      .layout-thumb[data-layout="line"]::before {
        content: "";
        position: absolute;
        left: 6px;
        top: 6px;
        width: 22px;
        height: 3px;
        background: #141724;
        border-radius: 999px;
      }

      .layout-thumb[data-layout="frame"]::before {
        content: "";
        position: absolute;
        inset: 5px;
        border: 1px solid rgba(20, 23, 36, 0.5);
        border-radius: 8px;
      }

      .layout-thumb[data-layout="split"]::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 34%;
        background: rgba(47, 128, 237, 0.25);
      }

      .layout-thumb[data-layout="grid"] {
        background-image: repeating-linear-gradient(
            90deg,
            rgba(17, 19, 31, 0.1),
            rgba(17, 19, 31, 0.1) 1px,
            transparent 1px,
            transparent 9px
          ),
          repeating-linear-gradient(
            0deg,
            rgba(17, 19, 31, 0.1),
            rgba(17, 19, 31, 0.1) 1px,
            transparent 1px,
            transparent 9px
          );
      }

      .layout-thumb[data-layout="pill"]::before {
        content: "";
        position: absolute;
        left: 6px;
        top: 8px;
        width: 60%;
        height: 10px;
        background: rgba(47, 128, 237, 0.3);
        border-radius: 999px;
      }

      .layout-thumb[data-layout="corner"]::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        width: 0;
        height: 0;
        border-top: 26px solid rgba(47, 128, 237, 0.3);
        border-right: 36px solid transparent;
      }

      .color-thumb[data-palette="linen"] {
        background: linear-gradient(135deg, #fbf8f3, #e6e1d6);
      }

      .color-thumb[data-palette="ice"] {
        background: linear-gradient(135deg, #f3f7fb, #dfe9f8);
      }

      .color-thumb[data-palette="sand"] {
        background: linear-gradient(135deg, #fbf6ee, #ecd6be);
      }

      .color-thumb[data-palette="mint"] {
        background: linear-gradient(135deg, #f2fbf7, #c9f0df);
      }

      .color-thumb[data-palette="rose"] {
        background: linear-gradient(135deg, #fff5f7, #ffd0dc);
      }

      .color-thumb[data-palette="midnight"] {
        background: linear-gradient(135deg, #f4f6fb, #c8d3f6);
      }

      .color-thumb[data-underlay="white"] {
        background: linear-gradient(135deg, #ffffff, #f1f1f1);
      }

      .color-thumb[data-underlay="cream"] {
        background: linear-gradient(135deg, #fff7e8, #f3e3c8);
      }

      .color-thumb[data-underlay="mist"] {
        background: linear-gradient(135deg, #eef3ff, #dfe7f7);
      }

      .color-thumb[data-underlay="mint"] {
        background: linear-gradient(135deg, #eefaf4, #d7f1e3);
      }

      .color-thumb[data-underlay="charcoal"] {
        background: linear-gradient(135deg, #1b1f2a, #0f1219);
      }

      .field {
        display: grid;
        gap: 6px;
        min-width: 240px;
      }

      .field label {
        font-size: 12px;
        color: var(--muted);
      }

      .preview-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
      }

      @media (max-width: 780px) {
        .page {
          padding: 20px 14px 60px;
        }

        .panel {
          padding: 14px;
        }

        .panel-head {
          justify-content: flex-end;
        }

        button.zip {
          width: 100%;
        }

        .preview-grid {
          display: flex;
          flex-wrap: nowrap;
          gap: 12px;
          overflow-x: auto;
          padding: 8px 0 16px;
          scroll-snap-type: x mandatory;
          /* Prevent horizontal scrollbar from affecting layout */
          -webkit-overflow-scrolling: touch;
          width: 100%;
          box-sizing: border-box;
        }

        .preview-card {
          scroll-snap-align: start;
          flex: 0 0 calc(80vw - 30px); /* Show 20% of next card */
          max-width: calc(80vw - 30px);
          min-width: 180px;
        }
        
      }

      .preview-wrap {
        position: relative;
        min-height: 180px;
        overflow: hidden;
        width: 100%;
      }

      .preview-card {
        background: rgba(12, 16, 28, 0.85);
        border-radius: 16px;
        padding: 10px;
        border: 1px solid var(--stroke);
        cursor: pointer;
      }

      .preview-card canvas {
        width: 100%;
        height: auto;
        display: block;
        border-radius: 10px;
      }

      .empty {
        color: var(--muted);
        text-align: center;
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        pointer-events: none;
      }

      .modal {
        position: fixed;
        inset: 0;
        background: rgba(8, 10, 18, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 50;
        padding: 24px;
      }

      .modal.open {
        display: flex;
      }

      .modal-card {
        width: min(520px, 90vw);
        background: rgba(14, 18, 32, 0.95);
        border: 1px solid var(--stroke);
        border-radius: 16px;
        padding: 18px;
        display: grid;
        gap: 12px;
      }

      .modal-card h3 {
        margin: 0;
        font-size: 18px;
      }

      .option-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 10px;
      }

      .option-card {
        display: grid;
        gap: 8px;
        padding: 10px;
        border-radius: 14px;
        border: 1px solid rgba(0, 212, 255, 0.35);
        background: rgba(10, 14, 26, 0.7);
        color: #cfeaff;
        font-size: 13px;
        font-weight: 600;
        text-align: left;
        cursor: pointer;
      }

      .option-card.muted {
        border-color: var(--stroke);
        color: var(--muted);
      }

      .option-thumb {
        height: 58px;
        border-radius: 10px;
        border: 1px solid var(--stroke);
        background: #0f1426;
        position: relative;
        overflow: hidden;
      }

      .option-thumb::after {
        content: "";
        position: absolute;
        inset: 8px;
        border-radius: 8px;
        border: 1px dashed rgba(0, 212, 255, 0.5);
      }

      .option-thumb.full::before {
        content: "";
        position: absolute;
        inset: 0;
        background: rgba(0, 212, 255, 0.12);
      }

      .option-thumb.top::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        height: 50%;
        background: rgba(0, 212, 255, 0.12);
      }

      .option-thumb.bottom::before {
        content: "";
        position: absolute;
        left: 0;
        bottom: 0;
        right: 0;
        height: 50%;
        background: rgba(0, 212, 255, 0.12);
      }

      .option-thumb.left::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 50%;
        background: rgba(0, 212, 255, 0.12);
      }

      .option-thumb.right::before {
        content: "";
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        width: 50%;
        background: rgba(0, 212, 255, 0.12);
      }

      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div class="page">
      <header>
        <h1>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫–∞—Ä—É—Å–µ–ª–µ–π –¥–ª—è Instagram</h1>
        <p>–°–æ–∑–¥–∞–≤–∞–π—Ç–µ –∫—Ä–∞—Å–∏–≤—ã–µ –∫–∞—Ä—É—Å–µ–ª–∏ –∑–∞ 3 –ø—Ä–æ—Å—Ç—ã—Ö —à–∞–≥–∞</p>
      </header>

      <!-- –®–∞–≥ 1 -->
      <section class="panel step-panel">
        <div class="step-header">
          <div class="step-number">1</div>
          <div class="step-title">–°–∫–æ–ø–∏—Ä—É–π –ø—Ä–æ–º–ø—Ç</div>
        </div>
        <p class="step-description">–ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–º–ø—Ç –¥–ª—è –ò–ò</p>
        <button class="primary" id="copyPromptBtn" style="height: 50px; font-size: 15px; padding: 0 22px; width: auto; display: inline-block; justify-self: start; background: linear-gradient(135deg, var(--accent-1), var(--accent-2));">üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–º–ø—Ç</button>
      </section>

      <!-- –®–∞–≥ 2 -->
      <section class="panel step-panel">
        <div class="step-header">
          <div class="step-number">2</div>
          <div class="step-title">–í—Å—Ç–∞–≤—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç –ò–ò –∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π</div>
        </div>
        <p class="step-description">–û—Ç–ø—Ä–∞–≤—å –ø—Ä–æ–º–ø—Ç –≤ –ª—é–±—É—é –Ω–µ–π—Ä–æ—Å–µ—Ç—å (ChatGPT, Claude, Gemini), –≤—Å—Ç–∞–≤—å –ø–æ–ª—É—á–µ–Ω–Ω—ã–π JSON –∏ –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É</p>
        <textarea id="jsonInput" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ JSON –æ—Ç –ò–ò –∑–¥–µ—Å—å..."></textarea>
        <div class="step-header" style="margin-top: 16px;">
          <div class="step-number">3</div>
          <button class="primary" id="fromJsonBtn" style="height: 50px; font-size: 15px; padding: 0 22px; width: auto;">‚ú® –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–∞—Ä—É—Å–µ–ª—å</button>
        </div>
      </section>

      <!-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ -->
      <section class="panel controls">
        <div class="panel-head">
          <h3 style="margin: 0; font-size: 16px;">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è</h3>
        </div>
        <div class="row">
          <label class="meta">
            –†–µ–∂–∏–º:
            <select id="modeSelect">
              <option value="carousel" selected>–ö–∞—Ä—É—Å–µ–ª—å</option>
              <option value="cover">–û–±–ª–æ–∂–∫–∞</option>
            </select>
          </label>
          <label class="meta">
            –†–∞–∑–º–µ—Ä:
            <select id="sizeSelect">
              <option value="800x1000">800 √ó 1000</option>
              <option value="1080x1080">1080 √ó 1080</option>
              <option value="1080x1920">1080 √ó 1920</option>
              <option value="1350x1080">1350 √ó 1080</option>
            </select>
          </label>
          <label class="meta">
            –®—Ä–∏—Ñ—Ç:
            <select id="fontSelect">
              <option value="Golos Text">Golos Text</option>
              <option value="Manrope" selected>Manrope</option>
              <option value="Inter">Inter</option>
              <option value="Rubik">Rubik</option>
              <option value="Montserrat">Montserrat</option>
            </select>
          </label>
        </div>
        <div class="row">
          <div class="field" style="min-width: 100%">
            <label>–¢–µ–º–∞ (–∫–ª–∏–∫)</label>
            <div class="picker" id="layoutPicker">
              <button class="chip active" data-layout="line" type="button">
                <div class="layout-thumb" data-layout="line"></div>
                Line
              </button>
              <button class="chip" data-layout="frame" type="button">
                <div class="layout-thumb" data-layout="frame"></div>
                Frame
              </button>
              <button class="chip" data-layout="split" type="button">
                <div class="layout-thumb" data-layout="split"></div>
                Split
              </button>
              <button class="chip" data-layout="grid" type="button">
                <div class="layout-thumb" data-layout="grid"></div>
                Grid
              </button>
              <button class="chip" data-layout="pill" type="button">
                <div class="layout-thumb" data-layout="pill"></div>
                Pill
              </button>
              <button class="chip" data-layout="corner" type="button">
                <div class="layout-thumb" data-layout="corner"></div>
                Corner
              </button>
            </div>
          </div>
        </div>
        <div class="row">
          <div class="field" style="min-width: 100%">
            <label>–¶–≤–µ—Ç (–∫–ª–∏–∫)</label>
            <div class="picker" id="colorPicker">
              <button class="chip" data-palette="linen" type="button">
                <div class="color-thumb" data-palette="linen"></div>
                Linen
              </button>
              <button class="chip" data-palette="ice" type="button">
                <div class="color-thumb" data-palette="ice"></div>
                Ice
              </button>
              <button class="chip" data-palette="sand" type="button">
                <div class="color-thumb" data-palette="sand"></div>
                Sand
              </button>
              <button class="chip" data-palette="mint" type="button">
                <div class="color-thumb" data-palette="mint"></div>
                Mint
              </button>
              <button class="chip" data-palette="rose" type="button">
                <div class="color-thumb" data-palette="rose"></div>
                Rose
              </button>
              <button class="chip active" data-palette="midnight" type="button">
                <div class="color-thumb" data-palette="midnight"></div>
                Midnight
              </button>
            </div>
          </div>
        </div>
        <div class="row">
          <div class="field">
            <label for="ctaInput">–ü—Ä–∏–∑—ã–≤ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è (—Å—Å—ã–ª–∫–∞/–Ω–∏–∫)</label>
            <input id="ctaInput" type="text" placeholder="@username –∏–ª–∏ https://..." />
          </div>
          <div class="field">
            <label for="ctaTextInput">–¢–µ–∫—Å—Ç –ø—Ä–∏–∑—ã–≤–∞</label>
            <input id="ctaTextInput" type="text" value="–ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞" />
          </div>
          <div class="field" style="align-self: flex-end; margin-bottom: 2px;">
            <button id="applyCtaBtn" class="secondary" style="height: 40px;">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
          </div>
        </div>
        <div class="row">
          <div class="field" style="min-width: 100%">
            <label>–¶–≤–µ—Ç –ø–æ–¥–ª–æ–∂–∫–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞ (–ø—Ä–∏ —Ñ–æ—Ç–æ)</label>
            <div class="picker" id="underlayPicker">
              <button class="chip active" data-underlay="white" type="button">
                <div class="color-thumb" data-underlay="white"></div>
                White
              </button>
              <button class="chip" data-underlay="cream" type="button">
                <div class="color-thumb" data-underlay="cream"></div>
                Cream
              </button>
              <button class="chip" data-underlay="mist" type="button">
                <div class="color-thumb" data-underlay="mist"></div>
                Mist
              </button>
              <button class="chip" data-underlay="mint" type="button">
                <div class="color-thumb" data-underlay="mint"></div>
                Mint
              </button>
              <button class="chip" data-underlay="charcoal" type="button">
                <div class="color-thumb" data-underlay="charcoal"></div>
                Charcoal
              </button>
            </div>
          </div>
        </div>
      </section>

      <!-- –†–µ–∑—É–ª—å—Ç–∞—Ç -->
      <section class="panel">
        <div class="panel-head" style="margin-bottom: 12px;">
          <h3 style="margin: 0; font-size: 16px;">–ì–æ—Ç–æ–≤—ã–µ —Å–ª–∞–π–¥—ã</h3>
          <button class="zip" id="downloadBtn" disabled style="display: none; padding: 6px 12px; background: linear-gradient(135deg, #8A2BE2, #6A0DAD); border: none; color: white; font-size: 14px;">–°–∫–∞—á–∞—Ç—å</button>
        </div>
        <div class="preview-wrap">
          <div id="preview" class="preview-grid"></div>
          <div id="empty" class="empty">
            <div style="display: grid; gap: 12px; text-align: center;">
              <div style="font-size: 48px;">üé®</div>
              <div>–ó–¥–µ—Å—å –ø–æ—è–≤—è—Ç—Å—è –≤–∞—à–∏ —Å–ª–∞–π–¥—ã</div>
              <div style="font-size: 14px; opacity: 0.7;">–í—ã–ø–æ–ª–Ω–∏—Ç–µ 3 —à–∞–≥–∞ –≤—ã—à–µ</div>
            </div>
          </div>
        </div>
      </section>
    </div>

    <div class="modal" id="imageModal" aria-hidden="true">
      <div class="modal-card">
        <h3>–§–æ—Ç–æ –Ω–∞ —Å–ª–∞–π–¥</h3>
        <div class="option-grid">
          <button class="option-card" data-mode="full">
            <div class="option-thumb full"></div>
            –ù–∞ –≤–µ—Å—å —Å–ª–∞–π–¥
          </button>
          <button class="option-card" data-mode="top">
            <div class="option-thumb top"></div>
            –°–≤–µ—Ä—Ö—É 1/2
          </button>
          <button class="option-card" data-mode="bottom">
            <div class="option-thumb bottom"></div>
            –°–Ω–∏–∑—É 1/2
          </button>
          <button class="option-card" data-mode="left">
            <div class="option-thumb left"></div>
            –°–ª–µ–≤–∞ 1/2
          </button>
          <button class="option-card" data-mode="right">
            <div class="option-thumb right"></div>
            –°–ø—Ä–∞–≤–∞ 1/2
          </button>
          <button class="option-card muted" data-mode="remove">
            <div class="option-thumb"></div>
            –£–±—Ä–∞—Ç—å —Ñ–æ—Ç–æ
          </button>
        </div>
        <button class="ghost" id="closeModalBtn">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </div>

    <input id="slideImageInput" type="file" accept="image/*" style="display: none" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" crossorigin="anonymous"></script>
    <script>
      const jsonInput = document.getElementById("jsonInput");
      const modeSelect = document.getElementById("modeSelect");
      const sizeSelect = document.getElementById("sizeSelect");
      const fontSelect = document.getElementById("fontSelect");
      const underlayPicker = document.getElementById("underlayPicker");
      const layoutPicker = document.getElementById("layoutPicker");
      const colorPicker = document.getElementById("colorPicker");
      const fromJsonBtn = document.getElementById("fromJsonBtn");
      const downloadBtn = document.getElementById("downloadBtn");
      const copyPromptBtn = document.getElementById("copyPromptBtn");
      const preview = document.getElementById("preview");
      const empty = document.getElementById("empty");
      const ctaInput = document.getElementById("ctaInput");
      const ctaTextInput = document.getElementById("ctaTextInput");
      const imageModal = document.getElementById("imageModal");
      const closeModalBtn = document.getElementById("closeModalBtn");
      const slideImageInput = document.getElementById("slideImageInput");

      const state = {
        slides: [],
        size: { w: 1080, h: 1080 },
        title: "",
        fontFamily: "Manrope",
        mode: "carousel",
        underlay: "white",
        slideImages: {},
        pendingImageIndex: null,
        pendingImageMode: null,
      };

      function isMobileDevice() {
        return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      }

      const palettes = {
        linen: {
          bgLight: "#fbf8f3",
          bgDark: "#141724",
          text: "#11131f",
          muted: "rgba(17, 19, 31, 0.55)",
          accents: ["#2f80ed", "#f2c14e", "#0fa3b1", "#f26419"],
        },
        ice: {
          bgLight: "#f3f7fb",
          bgDark: "#12151f",
          text: "#10121a",
          muted: "rgba(16, 18, 26, 0.55)",
          accents: ["#3a86ff", "#4cc9f0", "#5e60ce", "#72efdd"],
        },
        sand: {
          bgLight: "#fbf6ee",
          bgDark: "#18130f",
          text: "#17120f",
          muted: "rgba(23, 18, 15, 0.55)",
          accents: ["#b5651d", "#e09f3e", "#9b2226", "#6f1d1b"],
        },
        mint: {
          bgLight: "#f2fbf7",
          bgDark: "#0f1a16",
          text: "#0f1a16",
          muted: "rgba(15, 26, 22, 0.55)",
          accents: ["#2d9cdb", "#27ae60", "#6fcf97", "#16a085"],
        },
        rose: {
          bgLight: "#fff5f7",
          bgDark: "#1c1115",
          text: "#1c1115",
          muted: "rgba(28, 17, 21, 0.55)",
          accents: ["#ff5d8f", "#f28482", "#f6bd60", "#9b5de5"],
        },
        midnight: {
          bgLight: "#f4f6fb",
          bgDark: "#0b1020",
          text: "#0b1020",
          muted: "rgba(11, 16, 32, 0.55)",
          accents: ["#3f37c9", "#4895ef", "#4cc9f0", "#b5179e"],
        },
      };

      const underlays = {
        white: { color: "rgba(255, 255, 255, 0.98)", text: "#11131f" },
        cream: { color: "rgba(255, 247, 232, 0.98)", text: "#17120f" },
        mist: { color: "rgba(238, 243, 255, 0.98)", text: "#10121a" },
        mint: { color: "rgba(238, 250, 244, 0.98)", text: "#0f1a16" },
        charcoal: { color: "rgba(20, 24, 32, 0.92)", text: "#f4f6fb" },
      };

      const layouts = {
        line: "line",
        frame: "frame",
        split: "split",
        grid: "grid",
        pill: "pill",
        corner: "corner",
      };

      function parseSize(value) {
        const [w, h] = value.split("x").map(Number);
        return { w, h };
      }

      function parseStyledSegments(text) {
        const segments = [];
        let buf = "";
        let mode = "normal"; // normal | accent | bold
        let i = 0;

        const flush = () => {
          if (buf) segments.push({ text: buf, mode });
          buf = "";
        };

        while (i < text.length) {
          const ch = text[i];
          const rest = text.slice(i);

          if (rest.startsWith("<accent>")) {
            flush();
            mode = "accent";
            i += 8;
            continue;
          }

          if (rest.startsWith("</accent>")) {
            flush();
            mode = "normal";
            i += 9;
            continue;
          }

          if (rest.startsWith("<bold>")) {
            flush();
            mode = "bold";
            i += 6;
            continue;
          }

          if (rest.startsWith("</bold>")) {
            flush();
            mode = "normal";
            i += 7;
            continue;
          }

          buf += ch;
          i += 1;
        }

        flush();
        return segments;
      }

      function segmentsToWords(segments) {
        const words = [];
        const stickToPrev = /^(?:[,.!:;?)]|[¬ª‚Äù]|‚Ä¶)+$/;
        segments.forEach((seg) => {
          const parts = seg.text.split(/\s+/).filter(Boolean);
          parts.forEach((word) =>
            words.push({
              text: word,
              mode: seg.mode,
              noSpaceBefore: stickToPrev.test(word),
            })
          );
        });
        return words;
      }

      function fontWeightFor(mode, isTitle) {
        if (mode === "bold") return 800;
        if (mode === "accent") return 700;
        return isTitle ? 800 : 600;
      }

      function buildLinesFromWords(ctx, words, maxWidth, fontSize, fontFamily, isTitle) {
        const lines = [];
        let lineWords = [];
        let lineWidth = 0;
        const spaceWidth = ctx.measureText(" ").width;

        words.forEach((word) => {
          const weight = fontWeightFor(word.mode, isTitle);
          ctx.font = `${weight} ${fontSize}px "${fontFamily}", sans-serif`;
          const wordWidth = ctx.measureText(word.text).width;
          const extra = lineWords.length && !word.noSpaceBefore ? spaceWidth : 0;
          if (lineWidth + extra + wordWidth <= maxWidth || !lineWords.length) {
            lineWords.push({ ...word, width: wordWidth, weight });
            lineWidth += extra + wordWidth;
          } else {
            lines.push({ words: lineWords, width: lineWidth });
            lineWords = [{ ...word, width: wordWidth, weight }];
            lineWidth = wordWidth;
          }
        });

        if (lineWords.length) {
          lines.push({ words: lineWords, width: lineWidth });
        }
        return lines;
      }

      function pickAccent(text) {
        const pool = state.palette.accents;
        if (!pool || !pool.length) return "#2f80ed";
        let hash = 0;
        for (let i = 0; i < text.length; i++) {
          hash = (hash * 31 + text.charCodeAt(i)) >>> 0;
        }
        return pool[hash % pool.length];
      }

      function drawCoverImage(ctx, img, w, h) {
        const scale = Math.max(w / img.width, h / img.height);
        const drawW = img.width * scale;
        const drawH = img.height * scale;
        const dx = (w - drawW) / 2;
        const dy = (h - drawH) / 2;
        ctx.drawImage(img, dx, dy, drawW, drawH);
      }

      function drawCoverImageInRect(ctx, img, rect) {
        const scale = Math.max(rect.w / img.width, rect.h / img.height);
        const drawW = img.width * scale;
        const drawH = img.height * scale;
        const dx = rect.x + (rect.w - drawW) / 2;
        const dy = rect.y + (rect.h - drawH) / 2;
        ctx.save();
        ctx.beginPath();
        ctx.rect(rect.x, rect.y, rect.w, rect.h);
        ctx.clip();
        ctx.drawImage(img, dx, dy, drawW, drawH);
        ctx.restore();
      }

      function getImageRect(mode, w, h) {
        if (mode === "top") return { x: 0, y: 0, w, h: h / 2 };
        if (mode === "bottom") return { x: 0, y: h / 2, w, h: h / 2 };
        if (mode === "left") return { x: 0, y: 0, w: w / 2, h };
        if (mode === "right") return { x: w / 2, y: 0, w: w / 2, h };
        return { x: 0, y: 0, w, h };
      }

      function drawImageModeHint(ctx, rect, label, accent) {
        ctx.save();
        ctx.strokeStyle = `${accent}88`;
        ctx.lineWidth = Math.max(2, Math.round(Math.min(rect.w, rect.h) * 0.01));
        ctx.setLineDash([8, 6]);
        ctx.strokeRect(rect.x + 6, rect.y + 6, rect.w - 12, rect.h - 12);
        ctx.setLineDash([]);

        const badgePaddingX = 10;
        const badgePaddingY = 6;
        ctx.font = `600 ${Math.max(12, Math.round(Math.min(rect.w, rect.h) * 0.04))}px "Manrope", sans-serif`;
        const textW = ctx.measureText(label).width;
        const badgeW = textW + badgePaddingX * 2;
        const badgeH = Math.max(20, Math.round(Math.min(rect.w, rect.h) * 0.08));
        const bx = rect.x + rect.w - badgeW - 12;
        const by = rect.y + 12;
        ctx.fillStyle = "rgba(11, 16, 32, 0.65)";
        ctx.beginPath();
        ctx.roundRect(bx, by, badgeW, badgeH, Math.round(badgeH / 2));
        ctx.fill();

        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.fillText(label, bx + badgePaddingX, by + badgeH / 2);
        ctx.restore();
      }

      function drawSlide(canvas, text, index, total, isTitle, slideImage, isCta = false) {
        const { w, h } = state.size;
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d");
        
        // Declare accent at the beginning for use throughout the function
        const accent = pickAccent(state.title || text);

        // Background
        if (slideImage && slideImage.mode === "full") {
          drawCoverImage(ctx, slideImage.img, w, h);
          if (isTitle) {
            ctx.fillStyle = "rgba(255, 255, 255, 0.10)";
            ctx.fillRect(0, 0, w, h);
          }
        } else {
          ctx.fillStyle = state.palette.bgLight;
          ctx.fillRect(0, 0, w, h);
        }

        // Apply the same radial gradient to all slides (including CTA)
        const gradient = ctx.createRadialGradient(w * 0.2, h * 0.15, 10, w * 0.2, h * 0.15, w * 0.9);
        gradient.addColorStop(0, `${accent}1A`);
        gradient.addColorStop(1, `${accent}10`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, w, h);

        if (state.layout === layouts.line) {
          ctx.fillStyle = state.palette.bgDark;
          ctx.fillRect(w * 0.08, h * 0.08, w * 0.16, 6);
          ctx.beginPath();
          ctx.arc(w * 0.26, h * 0.083, 5, 0, Math.PI * 2);
          ctx.fill();
        } else if (state.layout === layouts.frame) {
          ctx.strokeStyle = `${accent}55`;
          ctx.lineWidth = Math.max(2, Math.round(w * 0.004));
          ctx.strokeRect(w * 0.07, h * 0.07, w * 0.86, h * 0.86);
        } else if (state.layout === layouts.split) {
          ctx.fillStyle = `${accent}22`;
          ctx.fillRect(0, 0, w * 0.32, h);
          ctx.fillStyle = state.palette.bgDark;
          ctx.fillRect(w * 0.08, h * 0.12, w * 0.1, 6);
        } else if (state.layout === layouts.grid) {
          ctx.strokeStyle = `${accent}33`;
          ctx.lineWidth = 1;
          const step = Math.max(24, Math.round(w * 0.06));
          for (let x = step; x < w; x += step) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
            ctx.stroke();
          }
          for (let y = step; y < h; y += step) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(w, y);
            ctx.stroke();
          }
        } else if (state.layout === layouts.pill) {
          ctx.fillStyle = `${accent}26`;
          const pillW = w * 0.38;
          const pillH = h * 0.08;
          const pillX = w * 0.08;
          const pillY = h * 0.08;
          ctx.beginPath();
          ctx.roundRect(pillX, pillY, pillW, pillH, pillH / 2);
          ctx.fill();
        } else if (state.layout === layouts.corner) {
          ctx.fillStyle = `${accent}28`;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(w * 0.25, 0);
          ctx.lineTo(0, h * 0.18);
          ctx.closePath();
          ctx.fill();
        }

        // CTA Slide - Same layout as other slides
        if (isCta) {
          // Use the same accent as calculated at the beginning of the function
          // Apply layout based on selected theme (same as other slides)
          if (state.layout === layouts.line) {
            ctx.fillStyle = state.palette.bgDark;
            ctx.fillRect(w * 0.08, h * 0.08, w * 0.16, 6);
            ctx.beginPath();
            ctx.arc(w * 0.26, h * 0.083, 5, 0, Math.PI * 2);
            ctx.fill();
          } else if (state.layout === layouts.frame) {
            ctx.strokeStyle = `${accent}55`;
            ctx.lineWidth = Math.max(2, Math.round(w * 0.004));
            ctx.strokeRect(w * 0.07, h * 0.07, w * 0.86, h * 0.86);
          } else if (state.layout === layouts.split) {
            ctx.fillStyle = `${accent}22`;
            ctx.fillRect(0, 0, w * 0.32, h);
            ctx.fillStyle = state.palette.bgDark;
            ctx.fillRect(w * 0.08, h * 0.12, w * 0.1, 6);
          } else if (state.layout === layouts.grid) {
            ctx.strokeStyle = `${accent}33`;
            ctx.lineWidth = 1;
            const step = Math.max(24, Math.round(w * 0.06));
            for (let x = step; x < w; x += step) {
              ctx.beginPath();
              ctx.moveTo(x, 0);
              ctx.lineTo(x, h);
              ctx.stroke();
            }
            for (let y = step; y < h; y += step) {
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(w, y);
              ctx.stroke();
            }
          } else if (state.layout === layouts.pill) {
            ctx.fillStyle = `${accent}26`;
            const pillW = w * 0.38;
            const pillH = h * 0.08;
            const pillX = w * 0.08;
            const pillY = h * 0.08;
            ctx.beginPath();
            ctx.roundRect(pillX, pillY, pillW, pillH, pillH / 2);
            ctx.fill();
          } else if (state.layout === layouts.corner) {
            ctx.fillStyle = `${accent}28`;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(w * 0.25, 0);
            ctx.lineTo(0, h * 0.18);
            ctx.closePath();
            ctx.fill();
          }

          // Use the same text layout as other slides instead of centered
          let marginX = w * 0.12;
          let marginY = h * 0.18;
          let maxWidth = w - marginX * 2;
          const footerSafe = Math.max(32, Math.round(h * 0.08));
          let maxHeight = h - marginY * 2 - footerSafe;

          const needsTightText = false; // CTA doesn't have image layout constraints
          const bodyScale = needsTightText ? 0.043 : 0.05;
          const bodyMin = needsTightText ? 0.03 : 0.034;
          let fontSize = Math.round(Math.min(w, h) * bodyScale); // Use body font size, not title size
          const minFont = Math.round(Math.min(w, h) * bodyMin);
          let lines = [];

          while (fontSize >= minFont) {
            ctx.font = `600 ${fontSize}px "${state.fontFamily}", sans-serif`;
            const segments = parseStyledSegments(text);
            const words = segmentsToWords(segments);
            lines = buildLinesFromWords(ctx, words, maxWidth, fontSize, state.fontFamily, false); // not a title
            const lineHeight = fontSize * 1.25;
            if (lines.length * lineHeight <= maxHeight) break;
            fontSize -= 2;
          }

          ctx.fillStyle = state.palette.text;
          ctx.textBaseline = "top";
          ctx.font = `600 ${fontSize}px "${state.fontFamily}", sans-serif`;
          const lineHeight = fontSize * 1.25;
          const linePaddingX = Math.max(14, Math.round(fontSize * 0.35));
          const linePaddingY = Math.max(10, Math.round(fontSize * 0.22));
          const lineGap = Math.round(fontSize * 0.28);

          const spaceWidth = ctx.measureText(" ").width;
          let y = marginY + (maxHeight - lines.length * (lineHeight + lineGap)) / 2;
          
          lines.forEach((line) => {
            let x = marginX;
            line.words.forEach((word, idx) => {
              ctx.font = `${word.weight} ${fontSize}px "${state.fontFamily}", sans-serif`;
              ctx.fillStyle = word.mode === "accent" ? accent : state.palette.text;
              if (idx > 0 && !word.noSpaceBefore) {
                x += spaceWidth;
              }
              ctx.fillText(word.text, x, y);
              x += word.width;
            });
            y += lineHeight + lineGap;
          });

          // Footer
          const footerSize = Math.round(fontSize * 0.45);
          ctx.font = `${footerSize}px "Manrope", sans-serif`;
          ctx.fillStyle = state.palette.muted;
          const footerY = h - Math.max(20, Math.round(h * 0.06));
          const slideText = `–°–ª–∞–π–¥ ${index + 1} / ${total}`;
          ctx.fillText(slideText, marginX, footerY);

          const handle = state.cta; // Use the state value for the footer
          if (handle) {
            ctx.textAlign = "right";
            ctx.fillText(handle, w - marginX, footerY);
            ctx.textAlign = "left";
          }
          return;
        }

        // Text layout
        let marginX = w * 0.12;
        let marginY = h * 0.18;
        let maxWidth = w - marginX * 2;
        const footerSafe = Math.max(32, Math.round(h * 0.08));
        let maxHeight = h - marginY * 2 - footerSafe;

        if (slideImage && slideImage.mode) {
          if (slideImage.mode === "top") {
            drawCoverImageInRect(ctx, slideImage.img, { x: 0, y: 0, w, h: h / 2 });
            marginY = h * 0.55;
            maxHeight = h - marginY - h * 0.08 - footerSafe * 0.6;
          } else if (slideImage.mode === "bottom") {
            drawCoverImageInRect(ctx, slideImage.img, { x: 0, y: h / 2, w, h: h / 2 });
            marginY = h * 0.12;
            maxHeight = h * 0.35 - footerSafe * 0.4;
          } else if (slideImage.mode === "left") {
            drawCoverImageInRect(ctx, slideImage.img, { x: 0, y: 0, w: w / 2, h });
            marginX = w * 0.58;
            maxWidth = w - marginX - w * 0.08;
            maxHeight = h - marginY * 2 - footerSafe;
          } else if (slideImage.mode === "right") {
            drawCoverImageInRect(ctx, slideImage.img, { x: w / 2, y: 0, w: w / 2, h });
            marginX = w * 0.12;
            maxWidth = w * 0.35;
            maxHeight = h - marginY * 2 - footerSafe;
          } else if (slideImage.mode === "full") {
            if (!isTitle) {
              marginX = w * 0.12;
              marginY = h * 0.12;
              maxWidth = w * 0.76;
              maxHeight = h * 0.62 - footerSafe * 0.5;
            }
          }
        }

        // Image placement hint (draw after image so it's visible)
        if (slideImage) {
          const rect = getImageRect(slideImage.mode, w, h);
          const labelMap = {
            full: "–§–æ—Ç–æ: –≤–µ—Å—å",
            top: "–§–æ—Ç–æ: –≤–µ—Ä—Ö",
            bottom: "–§–æ—Ç–æ: –Ω–∏–∑",
            left: "–§–æ—Ç–æ: –ª–µ–≤–æ",
            right: "–§–æ—Ç–æ: –ø—Ä–∞–≤–æ",
          };
          drawImageModeHint(ctx, rect, labelMap[slideImage.mode] || "–§–æ—Ç–æ", accent);
        }

        const needsTightText =
          slideImage &&
          (slideImage.mode === "left" || slideImage.mode === "right" || slideImage.mode === "top" || slideImage.mode === "bottom");
        const bodyScale = needsTightText ? 0.043 : 0.05;
        const bodyMin = needsTightText ? 0.03 : 0.034;
        let fontSize = Math.round(Math.min(w, h) * (isTitle ? 0.075 : bodyScale));
        const minFont = Math.round(Math.min(w, h) * (isTitle ? 0.048 : bodyMin));
        let lines = [];

        while (fontSize >= minFont) {
          ctx.font = `${isTitle ? 800 : 600} ${fontSize}px "${state.fontFamily}", sans-serif`;
          const segments = parseStyledSegments(text);
          const words = segmentsToWords(segments);
          lines = buildLinesFromWords(ctx, words, maxWidth, fontSize, state.fontFamily, isTitle);
          const lineHeight = fontSize * 1.25;
          if (lines.length * lineHeight <= maxHeight) break;
          fontSize -= 2;
        }

        const hasPhoto = isTitle && slideImage && slideImage.mode === "full";
        ctx.fillStyle = state.palette.text;
        ctx.textBaseline = "top";
        ctx.font = `${isTitle ? 800 : 600} ${fontSize}px "${state.fontFamily}", sans-serif`;
        const lineHeight = fontSize * 1.25;
        const blockHeight = lines.length * lineHeight;
        let y = marginY + (maxHeight - blockHeight) / 2;

        const linePaddingX = Math.max(14, Math.round(fontSize * 0.35));
        const linePaddingY = Math.max(10, Math.round(fontSize * 0.22));
        const lineGap = Math.round(fontSize * 0.28);

        const spaceWidth = ctx.measureText(" ").width;
        lines.forEach((line) => {
          if (hasPhoto) {
            const lineWidth = line.width;
            const rectW = lineWidth + linePaddingX * 2;
            const rectH = lineHeight + linePaddingY * 2;
            const rectX = marginX - linePaddingX;
            const rectY = y - linePaddingY;
            const underlay = underlays[state.underlay] || underlays.white;
            ctx.fillStyle = underlay.color;
            ctx.beginPath();
            ctx.roundRect(rectX, rectY, rectW, rectH, Math.max(10, Math.round(fontSize * 0.3)));
            ctx.fill();
          }

          let x = marginX;
          line.words.forEach((word, idx) => {
            ctx.font = `${word.weight} ${fontSize}px "${state.fontFamily}", sans-serif`;
            const underlay = underlays[state.underlay] || underlays.white;
            const baseText = hasPhoto ? underlay.text : state.palette.text;
            ctx.fillStyle = word.mode === "accent" ? accent : baseText;
            if (idx > 0 && !word.noSpaceBefore) {
              x += spaceWidth;
            }
            ctx.fillText(word.text, x, y);
            x += word.width;
          });
          y += lineHeight + lineGap;
        });

        // Footer
        const footerSize = Math.round(fontSize * 0.45);
        ctx.font = `${footerSize}px "Manrope", sans-serif`;
        ctx.fillStyle = state.palette.muted;
        const footerY = h - Math.max(20, Math.round(h * 0.06));
        const slideText = `–°–ª–∞–π–¥ ${index + 1} / ${total}`;
        ctx.fillText(slideText, marginX, footerY);

        const handle = ctaInput.value.trim();
        if (handle) {
          ctx.textAlign = "right";
          ctx.fillText(handle, w - marginX, footerY);
          ctx.textAlign = "left";
        }
      }

      function normalizeAiResult(result) {
        const title = (result.title || "").toString().slice(0, 60).trim();
        const slidesRaw = Array.isArray(result.slides) ? result.slides : [];
        const slides = slidesRaw
          .map((s) => s.toString().replace(/\s+/g, " ").trim())
          .filter(Boolean)
          .map((s) => (s.length > 200 ? s.slice(0, 197) + "..." : s));
        return { title, slides };
      }

      function renderPreviews() {
        preview.innerHTML = "";
        if (!state.slides.length && !state.title) {
          empty.style.display = "block";
          downloadBtn.disabled = true;
          downloadBtn.style.display = "none";
          return;
        }
        empty.style.display = "none";
        downloadBtn.style.display = "inline-flex";
        const allSlides =
          state.mode === "cover"
            ? [state.title || (state.slides[0] || "")].filter(Boolean)
            : [state.title, ...state.slides, state.cta].filter(Boolean);
        allSlides.forEach((text, index) => {
          const card = document.createElement("div");
          card.className = "preview-card";
          
          // Create container for canvas and download button
          const container = document.createElement("div");
          container.style.position = "relative";
          container.style.width = "100%";
          
          const canvas = document.createElement("canvas");
          const slideImage = state.slideImages[index];
          const isCta = state.cta && index === allSlides.length - 1 && state.mode !== "cover";
          drawSlide(canvas, text, index, allSlides.length, index === 0, slideImage, isCta);
          container.appendChild(canvas);
          
          // Add download button for mobile
          const downloadBtn = document.createElement("button");
          downloadBtn.innerHTML = "üì•";
          downloadBtn.style.position = "absolute";
          downloadBtn.style.top = "8px";
          downloadBtn.style.right = "8px";
          downloadBtn.style.background = "rgba(0, 0, 0, 0.5)";
          downloadBtn.style.border = "none";
          downloadBtn.style.borderRadius = "50%";
          downloadBtn.style.width = "32px";
          downloadBtn.style.height = "32px";
          downloadBtn.style.color = "white";
          downloadBtn.style.fontSize = "14px";
          downloadBtn.style.cursor = "pointer";
          downloadBtn.style.zIndex = "10";
          downloadBtn.style.display = "none"; // Initially hidden, shown on mobile
          downloadBtn.style.backdropFilter = "blur(4px)";
          
          // Add download functionality
          downloadBtn.addEventListener("click", (e) => {
            e.stopPropagation(); // Prevent opening image modal
            
            // Create temporary canvas to draw the slide
            const tempCanvas = document.createElement("canvas");
            const { w, h } = state.size;
            tempCanvas.width = w;
            tempCanvas.height = h;
            const ctx = tempCanvas.getContext("2d");
            
            // Redraw the slide on the temporary canvas
            drawSlide(tempCanvas, text, index, allSlides.length, index === 0, slideImage, isCta);
            
            // Create download link
            const link = document.createElement("a");
            link.download = `slide-${index + 1}_${w}x${h}.jpg`;
            link.href = tempCanvas.toDataURL("image/jpeg", 0.92);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          });
          
          container.appendChild(downloadBtn);
          card.appendChild(container);
          
          // Show download button on mobile
          if (isMobileDevice()) {
            downloadBtn.style.display = "flex";
            downloadBtn.style.alignItems = "center";
            downloadBtn.style.justifyContent = "center";
          }
          
          card.addEventListener("click", () => openImageModal(index));
          preview.appendChild(card);
        });
        document.getElementById("downloadBtn").disabled = false;
      }

      async function downloadZip() {
        if (!state.slides.length && !state.title) return;
        const zip = new JSZip();
        const { w, h } = state.size;
        const allSlides =
          state.mode === "cover"
            ? [state.title || (state.slides[0] || "")].filter(Boolean)
            : [state.title, ...state.slides, state.cta].filter(Boolean);

        for (let i = 0; i < allSlides.length; i++) {
          const canvas = document.createElement("canvas");
          const slideImage = state.slideImages[i];
          const isCta = state.cta && i === allSlides.length - 1 && state.mode !== "cover";
          drawSlide(canvas, allSlides[i], i, allSlides.length, i === 0, slideImage, isCta);
          const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
          const base64 = dataUrl.split(",")[1];
          zip.file(`slide-${i + 1}_${w}x${h}.jpg`, base64, { base64: true });
        }

        const blob = await zip.generateAsync({ type: "blob" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `carousel_${w}x${h}.zip`;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(link.href);
      }

      async function downloadImagesIndividually() {
        if (!state.slides.length && !state.title) return;
        const { w, h } = state.size;
        const allSlides =
          state.mode === "cover"
            ? [state.title || (state.slides[0] || "")].filter(Boolean)
            : [state.title, ...state.slides, state.cta].filter(Boolean);

        for (let i = 0; i < allSlides.length; i++) {
          const canvas = document.createElement("canvas");
          const slideImage = state.slideImages[i];
          const isCta = state.cta && i === allSlides.length - 1 && state.mode !== "cover";
          drawSlide(canvas, allSlides[i], i, allSlides.length, i === 0, slideImage, isCta);
          const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
          const link = document.createElement("a");
          link.href = dataUrl;
          link.download = `slide-${i + 1}_${w}x${h}.jpg`;
          document.body.appendChild(link);
          link.click();
          link.remove();
          await new Promise((r) => setTimeout(r, 200));
        }
      }

      function buildPrompt() {
        return `–¢—ã ‚Äî –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä –∫–∞—Ä—É—Å–µ–ª–µ–π –¥–ª—è Instagram, —Å–æ–∑–¥–∞—é—â–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ.

–ó–ê–î–ê–ß–ê:
–°–æ–∑–¥–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∫–∞—Ä—É—Å–µ–ª–∏ –≤ —Å—Ç—Ä–æ–≥–æ–º —Ñ–æ—Ä–º–∞—Ç–µ JSON –ø–æ –∑–∞–¥–∞–Ω–Ω–æ–π —Ç–µ–º–µ.

–§–û–†–ú–ê–¢ –û–¢–í–ï–¢–ê (—Ç–æ–ª—å–∫–æ JSON, –±–µ–∑ markdown, –±–µ–∑ –ø–æ—è—Å–Ω–µ–Ω–∏–π):
{
  "title": "—Å—Ç—Ä–æ–∫–∞ –¥–æ 60 —Å–∏–º–≤–æ–ª–æ–≤",
  "slides": ["—Å—Ç—Ä–æ–∫–∞ 1", "—Å—Ç—Ä–æ–∫–∞ 2", "..."]
}

–¢–†–ï–ë–û–í–ê–ù–ò–Ø –ö –°–û–î–ï–†–ñ–ê–ù–ò–Æ:
- title: –ø—Ä–∏–≤–ª–µ–∫–∞—é—â–∏–π –≤–Ω–∏–º–∞–Ω–∏–µ, –æ—Ç—Ä–∞–∂–∞—é—â–∏–π —Å—É—Ç—å —Ç–µ–º—ã
- slides: 3-8 —Å–ª–∞–π–¥–æ–≤, –∫–∞–∂–¥—ã–π –¥–æ 200 —Å–∏–º–≤–æ–ª–æ–≤
- –ö–∞–∂–¥—ã–π —Å–ª–∞–π–¥ ‚Äî —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–∞—è –º—ã—Å–ª—å, –±–µ–∑ –≤–æ–¥—ã
- –°—Ç–∏–ª—å: —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –º–∏–Ω–∏–º–∞–ª–∏–∑–º, –ª–∞–∫–æ–Ω–∏—á–Ω–æ—Å—Ç—å
- –ë–µ–∑ —Å–ø–∏—Å–∫–æ–≤, –Ω—É–º–µ—Ä–∞—Ü–∏–∏, —ç–º–æ–¥–∑–∏ –≤–Ω—É—Ç—Ä–∏ —Å–ª–∞–π–¥–æ–≤

–§–û–†–ú–ê–¢–ò–†–û–í–ê–ù–ò–ï –¢–ï–ö–°–¢–ê:
- <accent>—Ç–µ–∫—Å—Ç</accent> ‚Üí –≤—ã–¥–µ–ª–∏—Ç—å –∞–∫—Ü–µ–Ω—Ç–Ω—ã–º —Ü–≤–µ—Ç–æ–º
- <bold>—Ç–µ–∫—Å—Ç</bold> ‚Üí –≤—ã–¥–µ–ª–∏—Ç—å –∂–∏—Ä–Ω—ã–º —à—Ä–∏—Ñ—Ç–æ–º

–û–¢–í–ï–¢ –î–û–õ–ñ–ï–ù –ë–´–¢–¨:
- –í–∞–ª–∏–¥–Ω—ã–º JSON (–ø—Ä–æ–≤–µ—Ä—å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å!)
- –ë–µ–∑ markdown-—Ä–∞–∑–º–µ—Ç–∫–∏ (\`\`\`json –∏ —Ç.–¥.)
- –ë–µ–∑ –ø–æ—è—Å–Ω–µ–Ω–∏–π –ø–µ—Ä–µ–¥ –∏–ª–∏ –ø–æ—Å–ª–µ JSON

–¢–µ–º–∞:`;
      }

      function applyStateFromInputs() {
        state.mode = modeSelect.value || "carousel";
        state.size = parseSize(sizeSelect.value);
        state.fontFamily = fontSelect.value || "Manrope";
        const activeLayout = layoutPicker.querySelector(".chip.active")?.getAttribute("data-layout") || "line";
        const activePalette = colorPicker.querySelector(".chip.active")?.getAttribute("data-palette") || "midnight";
        const activeUnderlay = underlayPicker.querySelector(".chip.active")?.getAttribute("data-underlay") || "white";
        state.palette = palettes[activePalette] || palettes.midnight;
        state.layout = layouts[activeLayout] || layouts.line;
        state.underlay = activeUnderlay;
        const ctaTarget = ctaInput.value.trim();
        const ctaText = ctaTextInput.value.trim();
        state.cta = ctaTarget ? `${ctaText ? ctaText + " " : ""}${ctaTarget}`.trim() : "";
      }

      function openImageModal(index) {
        state.pendingImageIndex = index;
        imageModal.classList.add("open");
        imageModal.setAttribute("aria-hidden", "false");
      }

      function closeImageModal() {
        imageModal.classList.remove("open");
        imageModal.setAttribute("aria-hidden", "true");
        state.pendingImageIndex = null;
        state.pendingImageMode = null;
      }

      fromJsonBtn.addEventListener("click", () => {
        const raw = sanitizeJsonInput(jsonInput.value);
        if (!raw) {
          alert("–í—Å—Ç–∞–≤—å—Ç–µ JSON.");
          return;
        }
        try {
          const parsed = JSON.parse(raw);
          
          // Validate JSON structure
          if (typeof parsed !== 'object' || parsed === null) {
            alert("JSON –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–±—ä–µ–∫—Ç–æ–º —Å –ø–æ–ª—è–º–∏ 'title' –∏ 'slides'.");
            return;
          }
          
          if (!('title' in parsed) || !('slides' in parsed)) {
            alert("JSON –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –ø–æ–ª—è 'title' –∏ 'slides'.\n\n–ü—Ä–∏–º–µ—Ä:\n{\n  \"title\": \"...\",\n  \"slides\": [\"...\", \"...\"]\n}");
            return;
          }
          
          const normalized = normalizeAiResult(parsed);
          if (!normalized.title && !normalized.slides.length) {
            alert("JSON –±–µ–∑ –¥–∞–Ω–Ω—ã—Ö. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ –ø–æ–ª—è 'title' –∏ 'slides' –Ω–µ –ø—É—Å—Ç—ã–µ.");
            return;
          }
          applyStateFromInputs();
          state.title = normalized.title;
          state.slides = normalized.slides;
          state.slideImages = {};
          renderPreviews();
        } catch (err) {
          console.error("JSON Parse Error:", err);
          console.error("Input text:", raw.substring(0, 200));
          
          // Find position of error
          let errorMsg = "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π JSON.";
          if (err.message) {
            const match = err.message.match(/position (\d+)/);
            if (match) {
              const pos = parseInt(match[1]);
              const context = raw.substring(Math.max(0, pos - 30), Math.min(raw.length, pos + 30));
              errorMsg += `\n\n–û—à–∏–±–∫–∞ –æ–∫–æ–ª–æ:\n...${context}...\n${' '.repeat(33)}^`;
            } else {
              errorMsg += `\n\n${err.message}`;
            }
          }
          errorMsg += "\n\n–ü–æ–¥—Å–∫–∞–∑–∫–∞: —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ JSON —Ç–æ—á–Ω–æ –±–µ–∑ –ª–∏—à–Ω–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤ –¥–æ { –∏ –ø–æ—Å–ª–µ }";
          alert(errorMsg);
        }
      });

      function sanitizeJsonInput(input) {
        if (!input) return "";
        let text = input.replace(/^\uFEFF/, "").trim();
        
        // remove ```json ... ``` wrappers (multiline)
        text = text.replace(/^```(?:json)?\s*/i, "").replace(/\s*```$/i, "").trim();
        
        // remove single backticks if wrapped
        if (text.startsWith('`') && text.endsWith('`')) {
          text = text.slice(1, -1).trim();
        }
        
        // replace smart quotes with regular quotes
        text = text
          .replace(/[""‚Äû‚Äü]/g, '"')
          .replace(/['']/g, "'");
        
        // remove trailing commas before } or ]
        text = text.replace(/,(\s*[}\]])/g, '$1');
        
        // normalize line endings
        text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        
        return text;
      }

      function setActivePicker(container, attr, value) {
        const buttons = Array.from(container.querySelectorAll(".chip"));
        buttons.forEach((btn) => {
          const isActive = btn.getAttribute(`data-${attr}`) === value;
          btn.classList.toggle("active", isActive);
        });
      }

      layoutPicker.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-layout]");
        if (!btn) return;
        const value = btn.getAttribute("data-layout");
        setActivePicker(layoutPicker, "layout", value);
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      colorPicker.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-palette]");
        if (!btn) return;
        const value = btn.getAttribute("data-palette");
        setActivePicker(colorPicker, "palette", value);
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      underlayPicker.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-underlay]");
        if (!btn) return;
        const value = btn.getAttribute("data-underlay");
        setActivePicker(underlayPicker, "underlay", value);
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      sizeSelect.addEventListener("change", () => {
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      modeSelect.addEventListener("change", () => {
        if (state.mode === "cover") {
          sizeSelect.value = "1350x1080";
        }
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      fontSelect.addEventListener("change", () => {
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      imageModal.addEventListener("click", (event) => {
        if (event.target === imageModal) closeImageModal();
      });

      closeModalBtn.addEventListener("click", closeImageModal);

      imageModal.addEventListener("click", (event) => {
        const btn = event.target.closest("[data-mode]");
        if (!btn) return;
        const mode = btn.getAttribute("data-mode");
        if (mode === "remove") {
          if (state.pendingImageIndex !== null) {
            delete state.slideImages[state.pendingImageIndex];
            renderPreviews();
          }
          closeImageModal();
          return;
        }
        state.pendingImageMode = mode;
        slideImageInput.value = "";
        slideImageInput.click();
      });

      slideImageInput.addEventListener("change", () => {
        const file = slideImageInput.files?.[0];
        if (!file || state.pendingImageIndex === null || !state.pendingImageMode) {
          closeImageModal();
          return;
        }
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = () => {
            state.slideImages[state.pendingImageIndex] = {
              img,
              mode: state.pendingImageMode,
            };
            renderPreviews();
            closeImageModal();
          };
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
      });

      copyPromptBtn.addEventListener("click", async () => {
        const prompt = buildPrompt();
        await navigator.clipboard.writeText(prompt);
        copyPromptBtn.textContent = "‚úÖ –ü—Ä–æ–º–ø—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω! –í—Å—Ç–∞–≤—å –µ–≥–æ –≤ –ò–ò";
        setTimeout(() => (copyPromptBtn.textContent = "üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–º–ø—Ç"), 2500);
      });

      downloadBtn.addEventListener("click", () => {
        if (isMobileDevice()) {
          downloadImagesIndividually();
        } else {
          downloadZip();
        }
      });

      // Apply CTA changes without regenerating the carousel
      document.getElementById("applyCtaBtn").addEventListener("click", () => {
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
          
          // Visual feedback for button click
          const btn = document.getElementById("applyCtaBtn");
          btn.textContent = "‚úì –ü—Ä–∏–º–µ–Ω–µ–Ω–æ";
          btn.classList.add("primary");
          btn.classList.remove("secondary");
          
          setTimeout(() => {
            btn.textContent = "–ü—Ä–∏–º–µ–Ω–∏—Ç—å";
            btn.classList.add("secondary");
            btn.classList.remove("primary");
          }, 2000);
        }
      });

      // Also update CTA when input values change
      ctaInput.addEventListener("input", () => {
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });

      ctaTextInput.addEventListener("input", () => {
        if (state.title || state.slides.length) {
          applyStateFromInputs();
          renderPreviews();
        }
      });
    </script>
  </body>
</html>
